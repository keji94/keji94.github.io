<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shariding-jdbc分库分表笔记]]></title>
    <url>%2Fshariding-jdbc%2FShariding-jdbc%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%AC%94%E8%AE%B0%2Findex.html</url>
    <content type="text"><![CDATA[背景目前yjsj_jianyancgjg已接近1亿，yysy_jianyanbg已达到1000万，且这两张表数据增长十分快速，为了走可持续发展道路，决定对这两张表进行水平拆分。 被淘汰的tidb上周对tidb进行的压力测试，结果表明在持续并发下，tidb不够稳定，会莫名出现查询缓慢导致请求失败的情况，这在业务系统中是不能忍受的，所以排除将数据迁移至tidb的方法，还是使用传统的分库分表方案。 中间件的选择实现分库分表的方式有很多种，市面上也有很多的框架或工具。从切入点来说，整体分为五种: 编码层 在同一个项目中创建多个数据源，采用if else的方式，直接根据条件在代码中路由。Spring中有动态切换数据源的抽象类，具体参见AbstractRoutingDataSource。 如果项目不是很庞大，使用这种方式能够快速的进行分库。但缺点也是显而易见的，需要编写大量的代码，照顾到每个分支。当涉及跨库查询、聚合，需要循环计算结果并合并的场景，工作量巨大。 如果项目裂变，此类代码大多不能共用，大多通过拷贝共享。长此以往，码将不码。 框架层 这种情况适合公司ORM框架统一的情况，但在很多情况下不太现实。主要是修改或增强现有ORM框架的功能，在SQL中增加一些自定义原语或者hint来实现。 通过实现一些拦截器（比如Mybatis的Interceptor接口），增加一些自定义解析来控制数据的流向，效果虽然较好，但会改变一些现有的编程经验。 很多情况要修改框架源码，不推荐。 -驱动层 基于在编码层和框架层切入的各种缺点，真正的数据库中间件起码要从驱动层开始。什么意思呢？其实就是重新编写了一个JDBC的驱动，在内存中维护一个路由列表，然后将请求转发到真正的数据库连接中。 像TDDL、ShardingJDBC等，都是在此层切入。 包括Mysql Connector/J的Failover协议(具体指“load balancing”、“replication”、“farbic”等），也是直接在驱动上进行修改。 请求流向一般是这样的： 代理层 代理层的数据库中间件，将自己伪装成一个数据库，接受业务端的链接。然后负载业务端的请求，解析或者转发到真正的数据库中。 像MySQL Router、MyCat等，都是在此层切入。 请求流向一般是这样的： 实现层 SQL特殊版本支持，如Mysql cluster本身就支持各种特性，mariadb galera cluster支持对等双主，Greenplum支持分片等。 需要换存储，就不在讨论之列了。 驱动层和代理层对比通过以上层次描述，很明显，我们选择或开发中间件，就集中在驱动层和代理层。在这两层，能够对数据库连接和路由进行更强的控制和更细致的管理。但它们的区别也是明显的。 驱动层的特点 仅支持JAVA，支持丰富的DB 驱动层中间件仅支持Java一种开发语言，但支持所有后端关系型数据库。如果你的开发语言固定，后端数据源类型丰富，推荐使用此方案。 占用较多的数据库连接 驱动层中间件要维护很多数据库连接。比如一个分了10个 库 的表，每个java中的Connection要维护10个数据库连接。如果项目过多，则会出现连接爆炸（我们算一下，如果每个项目6个实例，连接池中minIdle等于5，3个项目的连接总数是 1065*3 = 900 个）。像Postgres这种每个连接对应一个进程的数据库，压力会很大。 运维负担小 所有集群的配置管理都集中在一个地方，运维负担小，DBA即可完成相关操作。 数据聚合在业务实例执行 数据聚合，比如count sum等，是通过多次查询，然后在业务实例的内存中进行聚合。 路由表存在于业务方实例内存中，通过轮询或者被动通知的途径更新路由表即可。 代理层的特点 异构支持，DB支持有限 代理层中间件正好相反。仅支持一种后端关系型数据库，但支持多种开发语言。如果你的系统是异构的，并且都有同样的SLA要求，则推荐使用此方案。 运维负担大 代理层需要维护数据库连接数量有限（MySQL Router那种粘性连接除外）。但作为一个独立的服务，既要考虑单独部署，又要考虑高可用，会增加很多额外节点，更别提用了影子节点的公司了。另外，代理层是请求唯一的入口，稳定性要求极高，一旦有高耗内存的聚合查询把节点搞崩溃了，都是灾难性的事故。 综合考虑后，medical-report使用sharding-jdbc做分库分表,将查报告相关的表单独放入一个数据库实例，对yjsj_jianyancgjg和yysy_jianyanbg做分表处理 信息整理影响业务和项目yjsj_jianyancgjg的影响:查询检验报告详情,调度Job yysy_jianyanbg的影响:文字报告、图片报告、健康档案、Job、报告定制 分表字段的选择现有的查询yjsj_jianyancgjg都是根据机构编号和jianyanid查询，所以可用于分表的字段有jigoubh（机构编号）、jianyanid(医院检验id)。 使用jigoubh分表，是切实可行的，但是数据分布可能不够均匀，比如单单一个金华市中心医院的数据就有1500万 使用jianyanid不一定可行，这个字段存储的是医院的检验id，可能重复，不一定都是数字，可能是字符串。另外用jianyanid分表，对于后面的扩展性不太好。 综合考虑之后，使用customer_id(客户编号)进行分表，由于这两张表都没有customer_id字段，需要用脚本补数据。 sql整理分表分表前，需要将表结构涉及到的所有sql拉出来，充分评估分表后对原有sql的影响。原有sql很大程度上是需要修改的，比如加上分片字段作为条件。 而在业务中，需要考虑是否能够职称sql改写，会不会缺少参数等。如果缺少，还需要对业务代码进行改造。 历史数据处理 step1: 将现有表结构以及数据迁移到单独的库，对于需要迁移的两张表，先放在临时表中。step2: 使用脚本分批次查询临时表中数据，插入到分表后的新表step3: 对于新产生的数据，通过mq的方式，在新系统插入。 step4: 前面三步弄好之后，进行业务迁移，业务迁移完毕之后，关闭DTS数据同步 对数据部分的影响分库分表的改造，涉及表结构以及数据的变更。需要和大数据部门沟通，让他们配合改造。]]></content>
      <categories>
        <category>shariding-jdbc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java面试宝典]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2Fjava%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%2Findex.html</url>
    <content type="text"><![CDATA[第一部分 Java基础关键字staticstatic 关键字的作用?static关键字可以让我们在不创建对象的情况下访问方法或变量。static除了可以修饰方法和变量外，还有static代码块，以及修饰内部类。被static修饰的数据，在内存中只会存在一份。合理利用static合理提升程序性能 静态变量 static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 static成员变量的初始化顺序按照定义的顺序进行初始化。 静态方法 static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 静态代码块 static代码块在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 为什么不能通过this访问static变量或者方法？this代表的是当前对象，被static修饰的变量或者方法，在类被加载的时候就会初始化，这个时候还没有创建对象。 static笔试题1234567891011121314151617181920212223242526public class StaticDemo extends ParentStaticDemo &#123; static &#123; System.out.println("static block run"); &#125; public StaticDemo() &#123; System.out.println("child constructor run"); &#125; public static void main(String[] args) &#123; new StaticDemo(); &#125;&#125;class ParentStaticDemo &#123; static &#123; System.out.println("parent static block run "); &#125; public ParentStaticDemo() &#123; System.out.println("parent constructor run"); &#125;&#125; 执行StaticDemo类的main()方法，输出顺序是怎样的？ 答案： parent static block run static block run parent constructor run child constructor run 在main()方法中，使用new StaticDemo()创建一个StaticDemo对象，但是在创建对象前需要先加载StaticDemo类，由于StaticDemo继承ParentStaticDemo，所以需要先加载ParentStaticDemo类，所以先执行的是”parent static block run “。加载完ParentStaticDemo后，开始加载StaticDemo，所以下一个输出的是static block run。StaticDemo加载完之后，开始创建StaticDemo，由于继承ParentStaticDemo，先执行父类的构造方法，所以先输出parent constructor run，最后是child constructor run。 finalfinal 通常表示无法被改变，在java中，final可以修饰变量、方法和类。 final变量 对于基本类型，final使数值恒定不变，而对于对象引用，final使引用恒定不变，一旦引用被初始化指向一个对象，就无法在将它指向另外一个变量。然而，对象其自身是可以修改的。 final方法 使用final方法的原因有两个，一是将方法锁定，确保在继承中是方法行为保持不变，不会被覆盖。二是效率。 在Java早期实现中，将一个方法指明为final，就是同意编译器将针对该方法的所有调用都改为内嵌调用。当编译器发现一个final方法调用命令时，它会跳过插入程序代码这种正常方式而执行方法调用机制(将参数调入栈，跳至方法方法代码处并执行，然后跳回并清理栈中的参数，处理返回值)，并且以方法体中的实际代码的副本来代替方法调用。这可以消除方法调用的开销。当然，如果一个方法很大，你的程序代码就会膨胀，所带来的性能提高会因为花费与方法内的时间量而被缩减。 需要注意的，JDK5以后，已经不推荐因为效率而使用final修饰方法，因为早期的虚拟机能够自动优化这种情况，只有你想明确禁止方法被覆盖时，才需要考虑使用final修饰方法。 final类 当将某个类定义为final类时，表名该类不能被集成。 transient在对象序列化的时候，有些变量不需要序列化，比如密码等，可以使用transient关键字来解决这个问题，transient修饰的变量不会被序列化。 volatilevolatile关键字的作用以及原理 synchronized访问修饰符集合ArrayListHashMap多线程IO反射和动态代理第二部分 常用框架spinrgmvcspringmybatisspringbootdubboshirosolr和eszookeepermaven第三部分 数据库mysqlredisredis有哪些数据结构？介绍下zset，它底层原理是什么？布隆过滤器和hyperloglogredis哨兵redis是怎么保证高可用的？redis为什么是单线程？mongodb第四部分 Java虚拟机第五部分 JavaWebtomcat你平时是如何进行Tomcat性能优化的?第六部分 设计模式第七部分 项目相关第八部分 算法相关第九部分 Linux第十部分 HR面试]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字的作用以及原理]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2Fvolatile%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86%2Findex.html</url>
    <content type="text"><![CDATA[物理计算机的并发问题CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。内存和硬盘的运算速度和CPU查了几个数量级。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I/O速度和CPU运算速度之间的不匹配问题。 所谓高速缓存也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 但是高速缓存引入了一个新的问题：缓存一致性（Cache Coherence）。在多核CPU系统中，每个CPU都有自己的高速缓存，而它们又公用一块主内存（Main Memory）。当多个CPU的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存不一致。如果真发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？ 解决缓存一致性问题一般来说，有两种方式解决缓存一致性问题 通过在总线加LOCK#锁的方式 通过缓存一致性协议 这2种方式都是硬件层面上提供的方式。 在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。 缓存一致性协议由于总线加Lock锁的方式效率低下，后来便出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 CPU乱序执行优化除了增加高速缓存外，为了使得处理器内部的运算单元能够尽量被充分利用，处理器可能会对输入代码进行乱序执行(Out-Of-Order Execution)优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行是一致的，但不保证程序中各个语句执行的先后顺序和输入的顺序一致。Java虚拟机的即时编译器也有类似的指令重排序（Instrution Reorder）优化。 Java内存模型Java内存模型和上面处理器、高速缓存、主内存间的交互关系有很高的可比性。Java虚拟机规范视图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽调各种硬件和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的内存访问效果。 Java内存模型规定了所有的变量(注意这里的变量包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量于方法参数，后者是线程私有的，不会被共享，自然就不会存在竞争问题。)都存储在主内存中。每条线程还有自己的工作内存(Working Memory,可与前面讲得处理器高速缓存类比)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存完成。 并发中的原子性、可见性、有序性问题原子性所谓原子性或原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程） 在java中，可以大致认为对基本数据类型的访问读写具备原子性 例如：1int a = 10; 但是下面这行代码便不是原子操作了12int a =10;a++; a++ 实际上包含了三个操作: 读取变量a的值； 对a进行加一的操作； 将计算后的值再赋值给变量a 这三个操作无法构成原子性。 如何保证原子性由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write,我们大致可以认为基本数据类型的访问读写是具备原子性的（例 外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。 但是在某些业务场景，需要更大范围的原子性保证。Java内存模型提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更髙展次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块一ynchronized关键字，因此在synchronized块之间的操作也具备原子性。 内存间的交互操作此处扩展下内存间交互操作，Java内存模型中定义了以下8种操作来完成。虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。 lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态； unlock(解锁):作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用； load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本 use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作； assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作； store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用； write（操作）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中 如果要把一个变量从主内存复制到工作内存。那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插人其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b, load b, load a。 volatile不能保证原子性 volatile不能保证原子性 由于volatile不能保证原子性，在使用volatile时要注意在不符合以下两条规则的运算场景中，我们仍然要通过加锁(使用synchronized或java.util.concurrent中的原子类)来保证原子性。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 可见性可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变景修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。 如何保证可见性synchronized同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的。 让你彻底理解Synchronized finalfinal关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。 volatile被volatile关键字修饰的变量则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。当一个变量被声明为valatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。 下面是一个在双检索单例中，使用volatile关键字的例子。 123456789101112131415161718192021222324252627public class Singleton &#123; /** * 声明单例对象 */ private static volatile Singleton instance; /** * 私有化构造器 */ private Singleton() &#123; &#125; /** * 双重检查加锁 * * @return Singleton */ public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 有序性所谓有序性是指：程序执行的顺序按照代码的先后顺序执行，禁止进行指令重排序。 Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的； 如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-ThreadAs-IfSerial Semantics）,后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。 如何保证有序性Java语言提供了 volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的。这条规则决定了持有同一个锁的两个同步块只能串行地进入。 除了这两个关键字外，Java 内存模型还具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从 happens-before 原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 如下是 happens-before 的8条原则，摘自 《深入理解Java虚拟机》。 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作； 锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作； volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作； 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C； 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作； 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生； 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行； 对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始； 在上面双检索单例的代码中，instance = new Singleton(); 这一行代码并不是原子性的，它的底层其实分为三个步骤: 为 Singleton 对象分配内存 memory = allocate(); 初始化对象 设置 instance 指向对象的内存空间 因为步骤 2 和步骤 3 需要依赖步骤 1，而步骤 2 和 步骤 3 并没有依赖关系，所以这两条语句有可能会发生指令重排，也就是或有可能步骤 3 在步骤 2 的之前执行。 在这种情况下，步骤 3 执行了，但是步骤 2 还没有执行，也就是说 instance 实例还没有初始化完毕，正好，在此刻，线程 2 判断 instance 不为 null，所以就直接返回了 instance 实例，但是，这个时候 instance 其实是一个不完全的对象，所以，在使用的时候就会出现问题。 而使用 volatile 关键字，也就是使用了 “对一个 volatile修饰的变量的写，happens-before于任意后续对该变量的读” 这一原则，对应到上面的初始化过程，步骤2 和 3 都是对 instance 的写，所以一定发生于后面对 instance 的读，也就是不会出现返回不完全初始化的 instance 这种可能。 volatile保证有序性的原理是通过添加内存屏障实现的。 # 让你彻底理解volatile]]></content>
      <categories>
        <category>java基础</category>
        <category>volatile</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis zset数据结构使用案例以及原理解析]]></title>
    <url>%2Fredis%2Fredis%20zset%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2Findex.html</url>
    <content type="text"><![CDATA[前言关于redis，我使用最多的数据结构就是简单的String。对于其他数据结构list、set、hash、zset，乃至于更高级的HyperLogLog、布隆过滤器，基本没有使用过，这次在工作中，恰好遇到需要使用zset的业务场景，特此记录。 zset数据结构介绍zset 可能是 Redis 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「跳跃列表」的数据结构。 zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。 zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。 zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。123456789101112131415161718192021222324252627282930313233&gt; zadd books 9.0 "think in java"(integer) 1&gt; zadd books 8.9 "java concurrency"(integer) 1&gt; zadd books 8.6 "java cookbook"(integer) 1&gt; zrange books 0 -1 # 按 score 排序列出，参数区间为排名范围1) "java cookbook"2) "java concurrency"3) "think in java"&gt; zrevrange books 0 -1 # 按 score 逆序列出，参数区间为排名范围1) "think in java"2) "java concurrency"3) "java cookbook"&gt; zcard books # 相当于 count()(integer) 3&gt; zscore books "java concurrency" # 获取指定 value 的 score"8.9000000000000004" # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题&gt; zrank books "java concurrency" # 排名(integer) 1&gt; zrangebyscore books 0 8.91 # 根据分值区间遍历 zset1) "java cookbook"2) "java concurrency"&gt; zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。1) "java cookbook"2) "8.5999999999999996"3) "java concurrency"4) "8.9000000000000004"&gt; zrem books "java concurrency" # 删除 value(integer) 1&gt; zrange books 0 -11) "java cookbook"2) "think in java" 业务场景本次使用到zset的业务是一个挂号底部消息通知的需求。当用户在微脉app上面挂号之后，就诊日期前两天时在底部出现消息提示，提示用户挂号信息，对用户进行引导。 这里只是简单的描述，实际需求比这个复杂很多。完成这个需求的第一步，便是获取用户的预约挂号记录。预约挂号秒的数据量很大，接近1000w，如果每次请求都去查库，势必对数据库造成很大压力。在查询完数据之后放入缓存，可以减缓数据库压力。但是app在推送咨询之后，流量会瞬间暴涨，如果这个时候没有缓存，流量瞬间到了数据库，很有可能造成数据库堵塞，甚至假死。 总之，需要避免app请求这个接口的时候直接去查库，只从redis中取数据，这就需要提前将数据放入缓存。当时考虑的方案有两个，一个是用调度在凌晨将最近3天的预约挂号记录查询出来，放入缓存。一个是当用户产生挂号业务(挂号，取消挂号等)时，发送消息异步更新缓存数据。 第一个方式简单粗暴，改动量小，不过还是要查询数据库，扫表。第二个方式改动量较大，但是不会对数据库造成压力。 综合考虑之后，我们选择了第二种。 redis数据结构的选择不管使用哪一种方案，都需要将用户的挂号信息放入redis，那么使用哪一种数据结构呢？。直接使用简单的String结构，一个挂号信息对应一条redis的key-value，现在我们每天的挂号量有几万，3天大概就是十几万的key，在可以接受的范围内，不过随着业务的发展，key的数量可能会暴涨，不是很好，后面还要优化。 这个时候想到了redis的zset数据结构，一个用户对应一个key，使用就诊日期的时间戳作为score，取的使用使用score取出数据。完全满足这个需求。 附上接受到挂号消息业务之后的伪代码: 12345678910//根据主键查询预约挂号信息MzgyMenZhenYYEntity entity = getRegistrationEntity(registrationId);//根据预约挂号的客户编号生成redis keyString key = GeneratorRedisKeyUtil.createRegistrationKey(entity.getYuyuekhbh());//根据就诊日期计算scorelong score = getScore(entity.getYuyuejzrq());//计算key的过期时间，始终保持key的过期时间在最大就诊日期之后long expireSecond = getExpireSecond(entity.getYuyuejzrq(), key);//放入redisredisClient.zadd(key, (double)score, JSON.toJSONString(convertEntity2DTO(entity)), (int)expireSecond); 取数据的伪代码: 123456789101112131415161718//根据主键查询预约挂号信息String key = GeneratorRedisKeyUtil.createRegistrationKey(customerId);Date now = new Date();//计算startScoreDate start = DateUtil.getSpecialDayStartTime(new Date());//计算endScoreDate end = DateUtil.getSpecialDayEndTime(DateUtil.plusDay(now, 2L));//根据score从redis取数据Set&lt;String&gt; set = redisClient.zrangeByScore(key, start.getTime(), end.getTime());//转换为出参需要的数据结构List&lt;RegistrationInfoDTO&gt; list = new ArrayList&lt;&gt;(set.size());for (String json : set) &#123; list.add(JSON.parseObject(json, RegistrationInfoDTO.class));&#125;return list; zset底层原理以下内容节选至老钱的《Redis深度历险:核心原理与应用》 侵删 zset 内部的排序功能是通过「跳跃列表」数据结构来实现的，它的结构非常特殊，也比较复杂。 因为 zset 要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。 我们需要这个链表按照 score 值进行排序。这意味着当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？ 想想一个创业公司，刚开始只有几个人，团队成员之间人人平等，都是联合创始人。随着公司的成长，人数渐渐变多，团队沟通成本随之增加。这时候就会引入组长制，对团队进行划分。每个团队会有一个组长。开会的时候分团队进行，多个组长之间还会有自己的会议安排。公司规模进一步扩展，需要再增加一个层级 —— 部门，每个部门会从组长列表中推选出一个代表来作为部长。部长们之间还会有自己的高层会议安排。 跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。 想想你老家在世界地图中的位置：亚洲–&gt;中国-&gt;安徽省-&gt;安庆市-&gt;枞阳县-&gt;汤沟镇-&gt;田间村-&gt;xxxx号，也是这样一个类似的结构。 「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于 L0、L1 和 L2 层，可以快速在不同层次之间进行「跳跃」。 定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问，那新插入的元素如何才有机会「身兼数职」呢？ 跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。 首先 L0 层肯定是 100% 了，L1 层只有 50% 的概率，L2 层只有 25% 的概率，L3 层只有 12.5% 的概率，一直随机到最顶层 L31 层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。 这还挺公平的，能不能进入中央不是靠拼爹，而是看运气。 关于跳跃列表的内部结构实现，请阅读第 36 节凌波微步 —— 探索「跳跃列表」内部结构]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO模型]]></title>
    <url>%2Funcategorized%2FJava-IO%E6%A8%A1%E5%9E%8B%2Findex.html</url>
    <content type="text"><![CDATA[Linux系统的五种IO模式Java 的 IO 模型本质上还是利用操作系统提供的接口来实现,所以最好先了解Linux底层模型。推荐阅读Linux IO模式及 select、poll、epoll详解 Java IO模型的演变BIO在JDK1.4之前，基于Java的所有Socket通信都采用同步阻塞模式(BIO)，这种一请求一应答的通信模型简化了上层的应用开发，但是在性能和可靠性方面却存在着巨大的瓶颈。当并发量增大，响应时间延迟增大之后，采用Java BIO开发的服务端只有通过硬件的不断扩容来满足高并发和低延迟，它极大的增加了企业的成本，随着集群规模的不断膨胀，系统的可维护性也面临巨大的挑战。 代码类似这样: 12345678910111213141516171819202122232425262728293031323334353637public class BlokingIoServer implements Runnable&#123; @Override public void run() &#123; try &#123; //将服务绑定到指定端口 ServerSocket ss = new ServerSocket(8888); while (!Thread.interrupted())&#123; //对 accept()方法的调 用将被阻塞，直到一个连接建立 final Socket clientSocket = ss.accept(); //为每个请求创建一个线程来处理 new Thread(new Handler(clientSocket)).start(); &#125; // or, single-threaded, or a thread pool &#125; catch (IOException ex) &#123; /* ... */ &#125; &#125; static class Handler implements Runnable &#123; final Socket socket; Handler(Socket s)&#123; socket = s; &#125; @Override public void run() &#123; try &#123; byte[] input = new byte[1024]; socket.getInputStream().read(input); byte[] output = process(input); socket.getOutputStream().write(output); &#125; catch (IOException ex) &#123; /* ... */ &#125; &#125; private byte[] process(byte[] cmd)&#123; //do something return null; &#125; &#125;&#125; Web服务，大多数有着类似的流程:Read request (从底层IO读取网络字节请求)Decode request (把读取的网络字节请求进行解码,封装成为业务请求对象)Process service (对解码封装后的业务请求对象进行业务处理)Encode reply (将业务逻辑处理完后的响应进行编码为底层IO可传输的字节响应)Send reply (利用底层IO发送已编码的字节响应) 不同之处在于，每一个步骤底层使用的技术和手段不同，比如:XML解析,文件传输,Web页面生成,计算服务….. 经典(传统)的网络服务设计如上图所示，对每个请求都会产生一个新的线程来进行处理，这种设计的缺点是，线程的创建本身是系统资源的一个开销，如果并发请求达到一定数量，响应将会变慢，甚至有可能因为系统资源不足而造成系统崩溃。 伪异步I/O编程为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化，后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M:线程池最大线程数N的比例关系，其中M可以远远大于N,通过线程池可以灵活的调配线程资源， 设置线程的最大值， 防止由于海量并发接入导致线程耗尽。 当有新的客户端接入的吋候，将客户端的Socket封装成一个Task （该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃线程对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class TimeServer &#123; public static void main(String[] args) throws IOException &#123; int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; try &#123; port = Integer.valueOf(args[0]); &#125; catch (NumberFormatException e) &#123; //采用默汄值 &#125; &#125; ServerSocket server = null; try &#123; server = new ServerSocket(port); System.out.println("The time server is start in port :" + port); Socket socket = null; TimeServerHandlerExecutePool singleExecutor = new TimeServerHandlerExecutePool(50, 10000); while (true) &#123; socket = server.accept(); singleExecutor.execute(new TimeServerHandler(socket)); &#125; &#125; finally &#123; if (server != null) &#123; System.out.println("The time server close11"); server.close(); server = null; &#125; &#125; &#125;&#125;public class TimeServerHandlerExecutePool &#123; private ExecutorService executor; public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123; executor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize, 120L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize)); &#125; public void execute(java.lang.Runnable task) &#123; executor.execute(task); &#125;&#125;public class TimeServerHandler implements Runnable &#123; private Socket socket; public TimeServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; BufferedReader in = null; PrintWriter out = null; try &#123; in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); out = new PrintWriter(this.socket.getOutputStream(), true); String currentTime = null; String body = null; while (true) &#123; body = in.readLine(); if (body == null) &#123; break; &#125; System.out.println("The time server receive order : " + body); currentTime = "QUERY TIME ORDER".equalsIgnoreCase(body) ? new Date(System.currentTimeMillis()) .toString() : "BAD ORDER"; System.out.println(currentTime); &#125; &#125; catch (Exception e) &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException el) &#123; el.printStackTrace(); &#125; if (out != null) &#123; out.close(); out = null; &#125; if (this.socket != null) &#123; try &#123; this.socket.close(); &#125; catch (IOException el) &#123; el.printStackTrace(); &#125; this.socket = null; &#125; &#125; &#125; &#125;&#125; 伪异步IO解决了线程的频繁创建销毁问题，但是如果通信对方返回应答时间过长，会引起级联故障，比如下面的场景: 服务端处理缓慢，返回应答消息耗费60s，平时只需要10ms。 采用伪异步IO的线程正在读取故障服务节点的响应，由于读取输入流是阻塞的，因此，它将会被同步阻塞60s。 假如所有的可用线程都被故障服务器阻塞，那后续所有的IO消息都将在队列中排队。 由于线程池采用阻塞队列实现，将队列积满之后，后续入队列的操作将被阻塞。 由于前段只有一个Accptor线程接口客户端接入，它被阻塞在线程池的同步阻塞队列之后，新的客户端请求消息将被拒绝，客户端会发生大量的连接超时。 由于几乎所有的连接都超时，调用者会认为系统崩溃，无法接受新的请求消息。 NIONIO，有人解释为new I/O,有人解释为Non-block I/O(我更倾向后者)。 正是由于Java传统BIO的拙劣表现，才使得Java支持非阻塞I/O的呼声日渐高涨，最终，JDK1.4版本提供了新的NIO类库，Java终于也可以支持非阻塞I/O 了。NIO主要的类和接口如下: 进行异步I/O操作的缓冲区ByteBuffer等; 进行异步I/O操作的管道Pipe； 进行各种I/O操作（异步或者同步）的Channel,包括ServerSocketChannel和 SocketChannel： 多种字符集的编码能力和解码能力； 实现非阻塞I/O操作的多路复用器selector： 基千流行的Perl实现的正则表达式类库； 文件通道FileChannelo。 新的NIO类库的提供，极大地促进了基于Java的异步非阻塞编程的发展和应用，但是，它依然有不完善的地方，特别是对文件系统的处理能力仍显不足，主要问题如下。 没有统一的文件属性（例如读写权限）； API能力比较弱，例如目录的级联创建和递归遍历，往往需要自己实现： 底层存储系统的一些高级API无法使用： 所有的文件操作都是同步阻塞调用，不支持异步文件读写操作。 2011年7月28日，JDKI.7正式发布。她将原来的NIO类库进行了升级，被称为NIO2.0。它主要提供了如下三个方面的改进。 能够提供能够批量获取文件属性的API，这些API具有平台无关性，不与特定的文件系统相耦合，另外它还提供了标准文件系统的SPI,供各个服务提供商扩展实现； 提供AIO功能，支持基于文件的异步I/O操作和针对网络套接字的异步操作； 完成JSR-5I定义的通道功能，包括对配置和多播数据报的支持等； NIO类库概念和功能介绍缓冲区BufferBuffer是一个对象，它包含一些要写入或者要读出的数据。在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，写入到缓冲区中。任何吋候访问NIO中的数据，都是通过缓冲区进行操作。 缓冲区实质上是一个数组。通常它是一个字节数组(ByteBuffer),也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置(limit)等信息。 最常用的缓冲区是ByteBuffer, 一个ByteBuffer提供了一组功能用于操作byte数组。除了 ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型(除了 Boolean类型)都对应有一种缓冲区，具体如下。 ByteBuffer：字节缓冲区 CharBuffer：字符缓冲区 ShortBuffer：短整型缓冲K IntBuffer：整形缓冲区 LongBuffer：长整形缓冲区 FloatBuffer：浮点型缓冲区 DoubleBuffer： 双精度浮点型缓冲区 每—个Buffer类都是Buffer接口的一个T实例。除了 ByteBuffer,每一个Buffe类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准I/O操作都使用ByteBuffer,所以它除了具有一般缓冲区的操作之外还提供一些特有的操作，方便网络读写。 管道channelChannel是一个通道，可以通过它读取和写入数据，它就像自来水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，流只是在一个方向上移动（一个流必须是InputStream或者OutputStream的子类），而且通道可以用于读、写或者同时用于读写。 Channel的类继承图如下。 因为Channel是全双工的，所以它可以比流更好地映射底层操作系统的API。特别是在UNIX网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。 多路复用器Selector多路复用器提供选择已经就绪的任务的能力。 简单来讲， Selector会不断地轮询注册在其上的Channel,如果某个Channel上面有新的TCP 连接接入、 读和写事件， 这个Channel就处于就绪状态， 会被Selector轮询出来， 然后通过SelectionKey可以获取就绪Channel的集合， 进行后续的I/O操作。 使用NIO实现服务端 123456789101112131415161718192021public class TimeServerNio &#123; public static void main(String[] args) &#123; //设置监听端口 int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; try &#123; port = Integer.valueOf(args[0]); &#125; catch (NumberFormatException e) &#123; //采用默认值 &#125; &#125; //创建了一个被称为MultiplexerTimeServer的多路复用类， 它是个一个独立 //的线程， 负责轮洵多路复用器Selctor,可以处理多个客户端的并发接入 MultiplexerTimeServer timeServer = new MultiplexerTimeServer(port); new Thread(timeServer, "NIO-MultiplexerTirneServer-001H").start(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public class MultiplexerTimeServer implements Runnable &#123; private Selector selector; private ServerSocketChannel servChannel; private volatile boolean stop; /** * 在构造方法中进行资源初始化， 创建多路复用器Selector、 * ServerSocketChannel,对 Channel 和 TCP 参数进行配置 * * @param port */ public MultiplexerTimeServer(int port) &#123; try &#123; selector = Selector.open(); servChannel = ServerSocketChannel.open(); //设置为异步非阻塞模式 servChannel.configureBlocking(false); servChannel.socket().bind(new InetSocketAddress(port), 1024); //注册selector servChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println("The time server is start in port : " + port); &#125; catch (IOException e) &#123; //资源初始化失败，退出系统 e.printStackTrace(); System.exit(1); &#125; &#125; public void stop() &#123; this.stop = true; &#125; @Override public void run() &#123; while (!stop) &#123; try &#123; //循环遍历selector,它的休眠时间为1s selector.select(1000); //返回就绪状态的Channel的SelectionKey集合 Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator(); SelectionKey key = null; //通过对就绪状态的Channel集合进行迭代， 可以进行网络的异步读写操作 while (it.hasNext()) &#123; key = it.next(); it.remove(); try &#123; handleInput(key); &#125; catch (Exception e) &#123; if (key != null) &#123; key.cancel(); if (key.channel() != null) &#123; key.channel().close(); &#125; &#125; &#125; &#125; &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源 if (selector != null) &#123; try &#123; selector.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void handleInput(SelectionKey key) throws IOException &#123; if (key.isValid()) &#123; // 处理新接入的请求消息 if (key.isAcceptable()) &#123; // Accept the new connection ServerSocketChannel ssc = (ServerSocketChannel) key.channel(); SocketChannel sc = ssc.accept(); sc.configureBlocking(false); // Add the new connection to the selector sc.register(selector, SelectionKey.OP_READ); &#125; if (key.isReadable()) &#123; // Read the data SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer readBuffer = ByteBuffer.allocate(1024); int readBytes = sc.read(readBuffer); if (readBytes &gt; 0) &#123; readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String body = new String(bytes, "UTF-8"); System.out.println("The time server receive order : " + body); String currentTime = "QUERY TIME ORDER" .equalsIgnoreCase(body) ? new java.util.Date( System.currentTimeMillis()).toString() : "BAD ORDER"; doWrite(sc, currentTime); &#125; else if (readBytes &lt; 0) &#123; // 对端链路关闭 key.cancel(); sc.close(); &#125; else &#123; ; // 读到0字节，忽略 &#125; &#125; &#125; &#125; /** * 将应答消息异步发送给客户端 * * @param channel channel * @param response response * @throws IOException exception */ private void doWrite(SocketChannel channel, String response) throws IOException &#123; if (response != null &amp;&amp; response.trim().length() &gt; 0) &#123; //将字符串编码成字节数组， 根据字节数组的容量创建ByteBuff byte[] bytes = response.getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length); //将字节数据复制到缓冲区 writeBuffer.put(bytes); writeBuffer.flip(); //将缓冲区中的字节数组发送出去 channel.write(writeBuffer); &#125; &#125;&#125; 使用NIO实现客户端 12345678910111213141516public class TimeClientNio &#123; public static void main(String[] args) &#123; int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; try &#123; port = Integer.valueOf(args[0]); &#125; catch (NumberFormatException e) &#123; // 采用默认值 &#125; &#125; new Thread(new TimeClientHandle("127.0.0.1", port), "TimeClient-001") .start(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class TimeClientHandle implements Runnable&#123; private String host; private int port; private Selector selector; private SocketChannel socketChannel; private volatile boolean stop; /** * implements Runnable * * @param host host * @param port port */ public TimeClientHandle(String host, int port) &#123; this.host = host == null ? "127.0.0.1" : host; this.port = port; try &#123; selector = Selector.open(); socketChannel = SocketChannel.open(); //设置为异步非阻塞模式 socketChannel.configureBlocking(false); &#125; catch (IOException e) &#123; e.printStackTrace(); System.exit(1); &#125; &#125; @Override public void run() &#123; try &#123; //发送连接请求 doConnect(); &#125; catch (IOException e) &#123; e.printStackTrace(); System.exit(1); &#125; while (!stop) &#123; try &#123; selector.select(1000); Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator(); SelectionKey key = null; while (it.hasNext()) &#123; key = it.next(); it.remove(); try &#123; handleInput(key); &#125; catch (Exception e) &#123; if (key != null) &#123; key.cancel(); if (key.channel() != null) key.channel().close(); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); System.exit(1); &#125; &#125; // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源 if (selector != null)&#123; try &#123; selector.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void handleInput(SelectionKey key) throws IOException &#123; if (key.isValid()) &#123; // 判断是否连接成功 SocketChannel sc = (SocketChannel) key.channel(); //如果返回值为true,说明客户端连接成功 if (key.isConnectable()) &#123; if (sc.finishConnect()) &#123; sc.register(selector, SelectionKey.OP_READ); doWrite(sc); &#125; else &#123; System.exit(1);// 连接失败，进程退出 &#125; &#125; if (key.isReadable()) &#123; //预分配1M的接收缓冲K用于读取应答消息， 调川Socketchannel的read()方法进行异步读取操作 ByteBuffer readBuffer = ByteBuffer.allocate(1024); int readBytes = sc.read(readBuffer); if (readBytes &gt; 0) &#123; readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String body = new String(bytes, "UTF-8"); System.out.println("Now is : " + body); this.stop = true; &#125; else if (readBytes &lt; 0) &#123; // 对端链路关闭 key.cancel(); sc.close(); &#125; else ; // 读到0字节，忽略 &#125; &#125; &#125; private void doConnect() throws IOException &#123; // 如果直接连接成功，则注册到多路复用器上，发送请求消息，读应答 if (socketChannel.connect(new InetSocketAddress(host, port))) &#123; socketChannel.register(selector, SelectionKey.OP_READ); doWrite(socketChannel); &#125; else &#123; //如果没有直接连接成功， 则说明服务端没有返回TCP握手应答消息， 但这并不代表连接失败， 我们需要将SocketChannel //注册到多路复用器Selector上， 注册SelectionKey.OP CONNECT»当服务端返回TCP //syn-ack消息后， Selector就能够轮询到这个SocketChannel处于连接就绪状态 socketChannel.register(selector, SelectionKey.OP_CONNECT); &#125; &#125; private void doWrite(SocketChannel sc) throws IOException &#123; byte[] req = "QUERY TIME ORDER".getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(req.length); writeBuffer.put(req); writeBuffer.flip(); sc.write(writeBuffer); //hasRemaining()方法对发送结果进行判断， 是否全部发送完成 if (!writeBuffer.hasRemaining()) &#123; System.out.println("Send order 2 server succeed."); &#125; &#125;&#125; NIO编程难度确实比同步阻塞BIO大很多， 上面的NIO 例子并没有考虑“ 半包读” 和“ 半包写” ， 如果加上这些， 代码将会更加复杂。 NIO优点总结 客户端发起的连接操作是异步的， 可以通过在多路复用器注册OP_CONNECT等待后续结果， 不需要像之前的客户端那样被同步阻塞。 Socketchannel的读写操作都是异步的， 如果没有可读写的数据它不会同步等待，直接返回， 这样I/O通信线程就可以处理其他的链路， 不需要同步等待这个链路可用。 线程模型的优化： 由于JDK的Selector在Linux等主流操作系统上通过epoll实现， 它没有连接句柄数的限制(只受限于操作系统的最大句柄数或者对单个进程的句柄限制)， 这意味着一个Selector线程可以同时处理成千上万个客户端连接， 而且性能不会随着客户端的增加而线性下降， 因此， 它非常适合做高性能、 高负载的网络服务器。 AIONIO2.0引入了新的异步通道概念，并提供了异步文件通道和异步套接字通道的实现。异步通道提供两种方式获取操作结果. 通过java.util.concurrent.Future类來表示异步操作的结果； 在执行异步操作的时候传入一个java.nio.channels。 CompletionHandler接口的实现类作为操作完成的回调。 NIO2.0的异步套接字通道是真正的异步非阻塞I/O,它对应UNIX网络编程中的事件驱动I/O (AIO),它不需要通过多路复用器(Selector)对注册的通道进行轮询操作即可实现异步读写， 从而简化了 NIO的编程模型。 aio服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public class TimeServerAio &#123; public static void main(String[] args) throws IOException &#123; int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; try &#123; port = Integer.valueOf(args[0]); &#125; catch (NumberFormatException e) &#123; // 采用默认值 &#125; &#125; //创建异步的时间服务器处理类 AsyncTimeServerHandler timeServer = new AsyncTimeServerHandler(port); new Thread(timeServer, "AIO-AsyncTimeServerHandler-001").start(); &#125;&#125;public class AsyncTimeServerHandler implements Runnable&#123; private int port; CountDownLatch latch; AsynchronousServerSocketChannel asynchronousServerSocketChannel; /** * 创建一个异步的服务端通道AsynchronousServerSocketChannel， 然后调H］它的 * bind h'法绑定监听端口， 如果端口合法且没被占用， 绑定成功， 打印启动成功提示到控 * 制台 * * @param port port */ public AsyncTimeServerHandler(int port) &#123; this.port = port; try &#123; asynchronousServerSocketChannel = AsynchronousServerSocketChannel .open(); asynchronousServerSocketChannel.bind(new InetSocketAddress(port)); System.out.println("The time server is start in port : " + port); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; //初始化CountDownLatch对象， 它的作用是在完成一组正在执行的操作之前， 允许当前的线程一直阻塞.在本例程中， 我们让线程在此阻塞, //防止服务端执行完成退出。 在实际项目应用中， 不需要启动独立的线程來处理 //AsynchronousServerSocketChannel latch = new CountDownLatch(1); doAccept(); try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void doAccept() &#123; //接收客户端的选接 asynchronousServerSocketChannel.accept(this, new AcceptCompletionHandler()); &#125;&#125;public class AcceptCompletionHandler implements CompletionHandler&lt;AsynchronousSocketChannel, AsyncTimeServerHandler&gt; &#123; @Override public void completed(AsynchronousSocketChannel result, AsyncTimeServerHandler attachment) &#123; attachment.asynchronousServerSocketChannel.accept(attachment, this); ByteBuffer buffer = ByteBuffer.allocate(1024); result.read(buffer, buffer, new ReadCompletionHandler(result)); &#125; @Override public void failed(Throwable exc, AsyncTimeServerHandler attachment) &#123; exc.printStackTrace(); attachment.latch.countDown(); &#125;&#125;public class ReadCompletionHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123; private AsynchronousSocketChannel channel; public ReadCompletionHandler(AsynchronousSocketChannel channel) &#123; if (this.channel == null) &#123; this.channel = channel; &#125; &#125; @Override public void completed(Integer result, ByteBuffer attachment) &#123; attachment.flip(); byte[] body = new byte[attachment.remaining()]; attachment.get(body); try &#123; String req = new String(body, "UTF-8"); System.out.println("The time server receive order : " + req); String currentTime = "QUERY TIME ORDER".equalsIgnoreCase(req) ? new java.util.Date( System.currentTimeMillis()).toString() : "BAD ORDER"; doWrite(currentTime); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; private void doWrite(String currentTime) &#123; if (currentTime != null &amp;&amp; currentTime.trim().length() &gt; 0) &#123; byte[] bytes = (currentTime).getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length); writeBuffer.put(bytes); writeBuffer.flip(); channel.write(writeBuffer, writeBuffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer buffer) &#123; // 如果没有发送完成，继续发送 if (buffer.hasRemaining()) &#123; channel.write(buffer, buffer, this); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; channel.close(); &#125; catch (IOException e) &#123; // ingnore on close &#125; &#125; &#125;); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; this.channel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; aio客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class TimeClientAio &#123; public static void main(String[] args) &#123; int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; try &#123; port = Integer.valueOf(args[0]); &#125; catch (NumberFormatException e) &#123; // 采用默认值 &#125; &#125; new Thread(new AsyncTimeClientHandler("127.0.0.1", port), "AIO-AsyncTimeClientHandler-001").start(); &#125;&#125;public class AsyncTimeClientHandler implements CompletionHandler&lt;Void, AsyncTimeClientHandler&gt;, Runnable&#123; private AsynchronousSocketChannel client; private String host; private int port; private CountDownLatch latch; public AsyncTimeClientHandler(String host, int port) &#123; this.host = host; this.port = port; try &#123; client = AsynchronousSocketChannel.open(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; latch = new CountDownLatch(1); client.connect(new InetSocketAddress(host, port), this, this); try &#123; latch.await(); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void completed(Void result, AsyncTimeClientHandler attachment) &#123; byte[] req = "QUERY TIME ORDER".getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(req.length); writeBuffer.put(req); writeBuffer.flip(); client.write(writeBuffer, writeBuffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer buffer) &#123; if (buffer.hasRemaining()) &#123; client.write(buffer, buffer, this); &#125; else &#123; ByteBuffer readBuffer = ByteBuffer.allocate(1024); client.read( readBuffer, readBuffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer buffer) &#123; buffer.flip(); byte[] bytes = new byte[buffer .remaining()]; buffer.get(bytes); String body; try &#123; body = new String(bytes, "UTF-8"); System.out.println("Now is : " + body); latch.countDown(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; client.close(); latch.countDown(); &#125; catch (IOException e) &#123; // ingnore on close &#125; &#125; &#125;); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; client.close(); latch.countDown(); &#125; catch (IOException e) &#123; // ingnore on close &#125; &#125; &#125;); &#125; @Override public void failed(Throwable exc, AsyncTimeClientHandler attachment) &#123; exc.printStackTrace(); try &#123; client.close(); latch.countDown(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 异步Socket Channel是被动执行对象， 我们不需要像 NIO编程那样创建一个独立的 I/O线程来处理读写操作。 对于AsynchronousServerSocketChannel和AsynchronousSocketChannel,它们都由JDK底层的线程池负责回调并驱动读写操作 #4中IO模型功能和特性对比]]></content>
  </entry>
  <entry>
    <title><![CDATA[==，equals，hashCode的区别和联系]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2Fequals%2F%3D%3D%EF%BC%8Cequals%EF%BC%8ChashCode%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%2Findex.html</url>
    <content type="text"><![CDATA[== 和equals== 比较的是对象在内存的地址。equals()定义在Object中。123public boolean equals(Object obj) &#123; return (this == obj);&#125; 这意味着所有对象都有equals()方法,并且默认情况下equals()方法和==一样比较的是对象在内存的地址值。一般引用数据类型之间的比较，需要重写equals，让其比较对象的字段值。 hashCode()方法的作用1public native int hashCode(); hashCode()方法注释翻译: 返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。 hashCode的的常规协定是: 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据equals(Object)方法两个对象相等，那么对两个对象调用hashCode方法必须产生相同的整数结果。 如果两个对象根据equals(java.lang.Object)方法是不相等的，那么调用这两个对象上的hashCode方法必须产生不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同的整数结果可能会提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） 注意这一句话： “支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。” 也就是说，虽然每个Java类都包含hashCode() 函数。但是，仅仅当创建并某个“类的散列表”时(比如HashMap)，该类的hashCode() 才有用(作用是：确定该类的每一个对象在散列表中的位置)；其它情况下(例如，创建类的单个对象，或者创建类的对象数组等等)，类的hashCode() 没有作用。 上面的散列表，指的是：Java集合中底层是散列表的类，如HashMap，Hashtable，HashSet。 关于散列表更过详细的介绍，可以参考哈希表、Java中HashMap equals()和hashCode()的区别和联系面试的时候，经常会被问到，为什么重写equals方法的时候需要重写hashCode()？我们来看一个只重写equals的demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.HashSet;import java.util.Objects;import org.apache.commons.lang3.builder.ToStringBuilder;import org.apache.commons.lang3.builder.ToStringStyle;/** * * @author keji * @version $Id: HashCodeAndEquals.java, v 0.1 2018/12/12 6:40 PM keji Exp $ */public class HashCodeAndEquals &#123; public static void main(String[] args) &#123; User p1 = new User(100,"eee"); User p2 = new User(100,"eee"); User p3 = new User(200,"aaa"); HashSet&lt;User&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(p1); hashSet.add(p2); hashSet.add(p3); System.out.printf("p1.equals(p2) : %s; p1(%d) p2(%d)\n", p1.equals(p2), p1.hashCode(), p2.hashCode()); System.out.printf("set:%s\n", hashSet); &#125; private static class User&#123; private int age; private String name; public User(int age, String name) &#123; this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; User user = (User)o; return age == user.age &amp;&amp; Objects.equals(name, user.name); &#125; @Override public String toString() &#123; return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE); &#125; &#125;&#125;输出结果:p1.equals(p2) : true; p1(189568618) p2(793589513)set:[HashCodeAndEquals.User[age=100,name=eee], HashCodeAndEquals.User[age=100,name=eee], HashCodeAndEquals.User[age=200,name=aaa]] 可以看到，在只重写equals，没有重写hashcode的情况下。equals相等，但是hashcode不相等，导致HashSet中仍然有重复元素：p1和p2。 当在原来的基础上，重写HashCode，再次执行main()12345678@Overridepublic int hashCode() &#123; return Objects.hash(age, name);&#125;输出结果如下：p1.equals(p2) : true; p1(104354) p2(104354)set:[HashCodeAndEquals.User[age=100,name=eee], HashCodeAndEquals.User[age=200,name=aaa]] 所有，当我们在HashMap,HashTable,HashSet等这些底层使用散列表的数据结构时，如果我们只重写equals()而不重写hashCode()，并不能很好的利用他们的特性。 但是，当我们明确对象不会再HashMap,HashTable,HashSet等这些数据结构中使用时，我们不重写hashCode()写是可以的。1234567891011121314151617181920User p1 = new User(100,"eee");User p2 = new User(100,"eee");User p3 = new User(200,"aaa");ArrayList&lt;User&gt; list1 = new ArrayList&lt;&gt;();list1.add(p1);list1.add(p2);list1.add(p3);ArrayList&lt;User&gt; list2 = new ArrayList&lt;&gt;();list2.add(p1);list2.add(p2);list2.add(p3);System.out.printf("p1.equals(p2) : %s; p1(%d) p2(%d)\n", p1.equals(p2), p1.hashCode(), p2.hashCode());System.out.printf("p1.equals(p3) : %s; p1(%d) p3(%d)\n", p1.equals(p3), p1.hashCode(), p3.hashCode());System.out.printf("list1.equals(list2) :%s\n",list1.equals(list2));输出结果：p1.equals(p2) : true; p1(104354) p2(104354)p1.equals(p3) : false; p1(104354) p3(103482)list1.equals(list2) :true 关于HashCode和equals的区别和联系，网络上有这样一个结论:当equals相等时,HashCode一定相等。当HashCode相等时，equals不一定相等。 这个结论不能说它是错的，但是它有一个前提是对equals和hashCode()进行了重写。 重写equals的同时重写hashCode(反之亦然)，这是一种规范。虽然前面说过如果对象不存储在HashMap、HashSet、HashTab等这些对象中时，hashCode是无用的，但是谁敢在设计这个对象的时候保证该对象以后不会再这些数据结构中使用？ 综上所述，重写equals的时候，要重写hashCode方法。]]></content>
      <categories>
        <category>java基础</category>
        <category>equals</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java集合之ArrayList 源码解析]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E9%9B%86%E5%90%88%2FArrayList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2Findex.html</url>
    <content type="text"><![CDATA[ArrayList是Java最常用的几种数据结构之一， 同时也是面试热点。了解其内部实现原理是非常必要的。 创建ArrayList123ArrayList&lt;Object&gt; list1 = new ArrayList&lt;&gt;();ArrayList&lt;Object&gt; list2 = new ArrayList&lt;&gt;(16);ArrayList&lt;Object&gt; list3 = new ArrayList&lt;&gt;(list2); ArrayList为我们提供了三个构造方法。我们创建ArrayList对象除了使用空参构造，还可以传递一个int数值，指定初始容量或者传递一个集合。 空参构造ArrayList()123456/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 空参构造非常简单，它会为我们创建一个空的集合。elementData成员变量是用来存放数据的对象,是一个Object[]，DEFAULTCAPACITY_EMPTY_ELEMENTDATA则是一个空的数组。 123456/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 注意DEFAULTCAPACITY_EMPTY_ELEMENTDATA类型为static final，表明其在内存中只有一份且禁止修改。 1234567/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access 注意elementData使用transient修饰。表明在采用Java默认的序列化机制的时候，被该关键字修饰的属性不会被序列化。而ArrayList类实现了java.io.Serializable接口，即采用了Java默认的序列化机制。但是elementData在网络传输的时候不序列化肯定是不行的，翻看源码会发现ArrayList自己实现了序列化和反序列化的方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 空参构造底层为我们创建的是一个空的数组，初始容量是0，这肯定没法存东西的，必然会使用的时候进行扩容。我们来看下add()方法1234567891011/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 首先，调用了ensureCapacityInternal()方法，入参传递了size+1，size+1表示elementData所需要的最小长度。这里的size变量，是用来记录ArrayList包含元素的多少的，初始值为0，我们调用ArrayList的size()方法，返回的就是该字段。123456/** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size; 看下ensureCapacityInternal()的源码:123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; 简单点说，该方法做了一件事情，判断当前数组能不能方法即将被添加的元素，如果不能，扩容。 首先调用了calculateCapacity()计算容量，代码如下:123456private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; 如果集合还没有被初始化，则初始化容量为10。如果已经初始化过了，直接返回。1234/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10; 调用完calculateCapacity()后，调用ensureExplicitCapacity(),这个方法做了两件事情：1.将modCount自增2.如果容量不够，扩容。12345678private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //扩容 grow(minCapacity);&#125; 我们先将modCount属性放到一边，看下扩容的方法grow()。 1234567891011121314151617/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 可以看到扩容后的容量为原容量的1.5倍+1。另外网上很多文章说ArrayList是无限扩容的，其实不是，它是有限度的。上面的代码有一个判断:12if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); 如果扩容后的容量比数组最大容量大，调用hugeCapacity()方法，并将扩容前所需要的最小容量传递的进去。1234567private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; hugeCapacity方法只在扩容时可能被调用，它的逻辑很简单，先做了个简单的判断，之后执行了一个三元表达式，如果扩容前所需最小容量大于数组最大长度，返回Integer的最大值，否则返回MAX_ARRAY_SIZE,MAX_ARRAY_SIZE的Integer的最大值-8。1234567/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; int的最大值为2的31次方-1，所以说ArrayList的最大容量为2的31次方-1。12345/** * A constant holding the maximum value an &#123;@code int&#125; can * have, 2&lt;sup&gt;31&lt;/sup&gt;-1. */@Native public static final int MAX_VALUE = 0x7fffffff; 回过头来在看我们调用空参构造创建一个ArrayList，并且第一次调用add()方法时发生了什么？扩容，是的，它会将默认的空数组扩容为一个长度为10的数组。 初始化指定集合大小ArrayList(int initialCapacity)《阿里巴巴Java开发手册》里面建议初始化集合时尽量显示的指定集合大小。为什么？读了上面的源码之后，应该可以知道答案了。1.节约内存，实际编码中，很多时候我们都可以知道ArrayList里面会放什么元素以及放多少元素。恰当的设置容器大小可以节约内存。2.避免扩容产生的性能损耗。比如我知道这个集合要放11个元素，那么我可以将集合的大小初始化为11，这样可以避免在添加第11个元素的时候，ArrayList扩容。 ArrayList的扩容底层调用了native方法System.arraycopy()简单点说就是将原来的数组中的元素拷贝到一个新的更大的数组中去。 看下指定初始容量构造的源码:1234567891011121314151617/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125; 逻辑非常简单，如果初始容量&gt;0，则创建一个该大小的数组。如果容量为0，则创建一个空数组。如果容量&lt;0，抛出异常。 初始化传递集合ArrayList(Collection&lt;? extends E&gt; c)12345678910111213141516171819/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 逻辑并不复杂，直接将集合转换为Object数组，赋值给了elementData属性。后面还做了一些保障性操作。 添加元素再探add(E e)方法前面已经看过一点add()方法的源码，知道它首先会确认容量是否够用，如果不够，则进行扩容。注意ArrayList的扩容时机和HashMap有区别，ArrayList只有底层数组已满，不能放下即将存入的对象才会扩容，HashMap的扩容和加载因子有关系，默认情况下，不是容器满了才扩容。123456789101112/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 在确保容量够用之后，直接要添加的元素赋值给elementData数组的下一个空间。 添加到指定位置add(int index, E element)123456789101112131415161718/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; //检查index是否在已有的数组中 if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException("Index:"+index+",Size:"+size); ensureCapacity(size + 1);//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 System.arraycopy(elementData, index, elementData, index+1, size-index);//将index及其后边的所有的元素整块后移，空出index位置 elementData[index] = element;//插入元素 size++;//已有数组元素个数+1&#125; 使用这个方法，务必注意index的值需要在已经元素的下标之间。 添加所有addAll(Collection&lt;? extends E&gt; c)123456789101112131415161718192021/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray();//将c集合转化为对象数组a int numNew = a.length;//获取a对象数组的容量 ensureCapacity(size + numNew);//确保对象数组elementData有足够的容量，可以将新加入的a对象数组加进去 System.arraycopy(a, 0, elementData, size, numNew);//将对象数组a拷贝到elementData中去 size += numNew;//重新设置elementData中已加入的元素的个数 return numNew != 0;//若加入的是空集合则返回false&#125; ##添加所有到指定位置addAll(int index, Collection&lt;? extends E&gt; c)12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 删除元素删除指定索引元素 E remove(int index)。123456789101112131415161718192021222324252627/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; //索引边界检查 rangeCheck(index); //计数器自增 modCount++; //取得被删除元素 E oldValue = elementData(index); //计算要移动的索引值 int numMoved = size - index - 1; if (numMoved &gt; 0) //如果删除的不是最后一个元素，进行数组拷贝 System.arraycopy(elementData, index+1, elementData, index, numMoved); //将最后一个元素置为null，下次gc回收 elementData[--size] = null; // clear to let GC do its work //返回被删除的值 return oldValue;&#125; 删除指定值的元素 remove(Object o)1234567891011121314151617181920212223242526272829/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; if (o == null) &#123;//移除对象数组elementData中的第一个null for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123;//移除对象数组elementData中的第一个o for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 12345678910/* * 删除单个位置的元素，是ArrayList的私有方法 */private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0)//删除的不是最后一个元素 System.arraycopy(elementData, index + 1, elementData, index,numMoved);//删除的元素到最后的元素整块前移 elementData[--size] = null; //将最后一个元素设为null，在下次gc的时候就会回收掉了&#125; remove(Object o)需要遍历数组，remove(int index)不需要，只需要判断索引符合范围即可，所以，通常：后者效率更高。 获取元素获取单个元素get(int index)1234567891011/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; rangeCheck(index);//检查索引范围 return (E) elementData[index];//返回元素，并将Object转型为E&#125; 12345678910/** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 注意rangeCheck检查的是size的大小，也就是实际存储元素个数，而不是容器的实际容量。 #遍历元素 iterator()123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; Itr是ArryList的一个私有内部类，实现了Iterator接口。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private class Itr implements Iterator&lt;E&gt; &#123; int cursor = 0;//标记位：标记遍历到哪一个元素 int expectedModCount = modCount;//标记位：用于判断是否在遍历的过程中，是否发生了add、remove操作 //检测对象数组是否还有元素 public boolean hasNext() &#123; return cursor != size();//如果cursor==size，说明已经遍历完了，上一次遍历的是最后一个元素 &#125; //获取元素 public E next() &#123; checkForComodification();//检测在遍历的过程中，是否发生了add、remove操作 try &#123; E next = get(cursor++); return next; &#125; catch (IndexOutOfBoundsException e) &#123;//捕获get(cursor++)方法的IndexOutOfBoundsException checkForComodification(); throw new NoSuchElementException(); &#125; &#125; //检测在遍历的过程中，是否发生了add、remove等操作 final void checkForComodification() &#123; if (modCount != expectedModCount)//发生了add、remove操作,这个我们可以查看add等的源代码，发现会出现modCount++ throw new ConcurrentModificationException(); &#125; @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125;&#125; 需要注意的是这里有一个Java集合的fail-fast事件。你可能已经注意到，我们在调用add()、remove()这些修改集合的方法时，都会修改一个属性modCount。而我们在遍历集合时，首先会保存一份modCount，然后在遍历时，将保存的modCount和成员变量modCount对比，如果不一样，说明被集合已经被修改，抛出ConcurrentModificationException，产生fail-fast事件。 #其他 设置元素set(int index, E element)123456789/** * 更换特定位置index上的元素为element，返回该位置上的旧值 */ public E set(int index, E element) &#123; RangeCheck(index);//检查索引范围 E oldValue = (E) elementData[index];//旧值 elementData[index] = element;//该位置替换为新值 return oldValue;//返回旧值 &#125; 判断元素是否存在1234567891011121314151617181920212223242526272829303132333435363738/** * 判断动态数组是否包含元素o */public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;/** * 返回第一个出现的元素o的索引位置 */public int indexOf(Object o) &#123; if (o == null) &#123;//返回第一个null的索引 for (int i = 0; i &lt; size; i++) if (elementData[i] == null) return i; &#125; else &#123;//返回第一个o的索引 for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;//若不包含，返回-1&#125;/** * 返回最后一个出现的元素o的索引位置 */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size - 1; i &gt;= 0; i--) if (elementData[i] == null) return i; &#125; else &#123; for (int i = size - 1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; #总结1.ArrayList的底层是数组，初始容量是10，当数组满了之后，继续添加元素时，会扩容到原来的1.5倍+1。2.ArrayList保存了一个modCount属性，修改集合的操作都会让其自增。如果在遍历的时候modCount被修改，则会抛出异常，产生fail-fast事件。3.ArrayList内部还维护了一个size属性，它是用来记录数组中的实际元素个数。size,modCount，elementData这些成员变量，都注定了ArrayList线程不安全。4.ArrayList实现了Iterator接口，这表明遍历ArrayList使用普通for循环比使用foreach更快，至于为什么可以参考ArrayList集合实现RandomAccess接口有何作用？为何LinkedList集合却没实现这接口？]]></content>
      <categories>
        <category>java基础</category>
        <category>集合</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 虚拟机内存模型]]></title>
    <url>%2FJVM%2FJava%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2Findex.html</url>
    <content type="text"><![CDATA[JVM内存模型根据《Java虚拟机规范(Java SE 7 版)》的规定，Java虚拟机所管理的内存包括几下几个运行时数据数据: 程序计数器程序计数器是一块较小的内存空间，它可以看做当前线程所执行的字节码的行号指示器,每个线程都有一个程序计数器。如果线程执行的是Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的Native方法，这个计数器的值则为空。 Java虚拟机栈线程私有，生命周期和线程相同。每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型(指向了一条字节码指令的地址)。 Java虚拟机规范，规定了这个区域的两种异常状况:如果线程请求的栈深度大于虚拟机锁允许的深度，将抛出StackOverflowError；如果虚拟机可以动态扩展(大部分虚拟机都支持),在扩展时无法申请到足够的内存，将抛出OutOfMemoryError异常。 本地方法栈线程私有，作用和虚拟机栈非常相似，只不过虚拟机栈为Java方法服务，本地方法栈为native方法服务。 Java堆Java虚拟机所管理的最大的一块内存，几乎所有的对象实例都在这里分配内存。被所有线程共享。堆内存也是java dc发生的主要区域，因此也被称为GC堆。内内存继续细分的话，可以分为Eden区、From Survivor区、To Survivor区等。堆内存可以是不连续的内存空间，只要逻辑上是连续的即可。可以通过-Xmx和-Xms控制大小。 方法区线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编辑器编译后的代码等数据。相对而言，GC很少发生在该区域。 方法区有一个运行时常量池(Runtime Constant Pool)，Class文件除了有类的版本、字段、方法接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring@Value注解总是null问题记录]]></title>
    <url>%2Fspring%2FSpring%40Value%E6%B3%A8%E8%A7%A3%E6%80%BB%E6%98%AFnull%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2Findex.html</url>
    <content type="text"><![CDATA[问题描述在使用@value注解之后，字段总是为空。后来发现是因为字段使用了static修饰。123456789@Componentpublic class TestValue &#123; @Value(&quot;$&#123;appEnv&#125;&quot;) private static String appenv; //null public String test() &#123; return appenv; &#125;&#125; 原因spring的依赖注入不支持为static变量注入。spring 依赖注入的底层原理还是利用反射来创建对象。而static变量，在jvm加载类的时候便已经创建，存在于方法区，被所有实例共享，属于类的属性而不是对象的属性。spring是基于对象层面的依赖注入。 解决1.使用set方法注入，非静态setter 方法注入静态变量。如：1234567891011121314import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class GlobalValue &#123; public static String DATABASE; @Value(&quot;$&#123;mongodb.db&#125;&quot;) public void setDatabase(String db) &#123; DATABASE = db; &#125; &#125; 2.@PostConstruct方式实现1234567891011121314151617import org.mongodb.morphia.AdvancedDatastore; import org.springframework.beans.factory.annotation.Autowired; @Component public class MongoFileOperationUtil &#123; @Autowired private static AdvancedDatastore dsForRW; private static MongoFileOperationUtil mongoFileOperationUtil; @PostConstruct public void init() &#123; mongoFileOperationUtil = this; mongoFileOperationUtil.dsForRW = this.dsForRW; &#125; &#125; @PostConstruct，会在构造方法之后执行。其给static变量赋值的原理和set方法差不多，都是调用非静态方法给静态变量赋值]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[netty系列之--1.netty框架基本介绍]]></title>
    <url>%2Fnetty%2Fnetty1%2Findex.html</url>
    <content type="text"><![CDATA[netty是什么？]]></content>
      <categories>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性 使用Optional避免NPE]]></title>
    <url>%2Fjava8%2Foptional%2Findex.html</url>
    <content type="text"><![CDATA[前言相信每一个Java程序员都碰到过NPE异常，每个避免NPE，往往会在代码中写很多if判断，形成代码污染。为了解决这个问题，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。 Optional类介绍Optional类存在于java.util包中，它是一个用来存放null值或者非null值的容器。如果容器内有值，isPresent()方法返回true,使用get()方法可以取到这个值.除此之外，还提供了基于对值存在与否的判断的其他方法，比如：orElse()(如果值不存在，则返回默认值)ifPresent()(如果值存在，则执行代码块)需要注意的是，这是一个“基于值(value-based)”的类，使用对身份敏感的操作，比如(比较符号’==’,一致性哈希或同步)都可能出现意想不到的结果，这类操作应该避免。什么是value-based class? Optional类的方法注:第一排:m:表示方法,左下角有个白色标志的表示static方法 f:表示变量第二排:上锁表示为private方法,解锁表示public第三排:方法或变量名称第四排:方法返回值 我们一个个看 empty() 创建一个空的Optional对象public static Optional empty()返回一个Optional对象，其存储的值是null1234Optional&lt;Object&gt; emptyOptional = Optional.empty();System.out.println(emptyOptional);result:Optional.empty 注意判断Optional值是否为Null,不要使用null == Optional.empty(),而应该使用isPresent() of() 创建一个不为空的Optional对象，如果值为null，抛出NPE1234Optional&lt;Object&gt; optional = Optional.of(1);System.out.println(optional);result:Optional[1] ofNullable()创建一个可为空的Optional对象12345678Optional&lt;Object&gt; emptyOptional = Optional.ofNullable(null);Optional&lt;Long&gt; longOptional = Optional.ofNullable(2L);System.out.println(emptyOptional);System.out.println(longOptional);result: Optional.empty Optional[2] isPresent() 判断值是否存在public boolean isPresent()12345678910Optional&lt;Object&gt; optional = Optional.of(1);Optional&lt;Object&gt; emptyOptional = Optional.ofNullable(null);boolean isPresent = optional.isPresent();boolean emptyOptionalPresent = emptyOptional.isPresent();System.out.println(isPresent);System.out.println(emptyOptionalPresent);result: true false ifPresent() 注意不是isPresent()当值存在的时候，执行传入的代码1234Optional&lt;Object&gt; optional = Optional.of(1);optional.ifPresent(e-&gt; System.out.println((Integer)e+1));result:2 orElse() 如果存在返回原来的值，不存在，则返回指定的值public T orElse(T other) 12345678910Optional&lt;Object&gt; optional = Optional.of(1);Optional&lt;Object&gt; emptyOptional = Optional.empty();Object orElse = optional.orElse(2);Object orElse2 = emptyOptional.orElse(2);System.out.println(orElse);System.out.println(orElse2);result: 1 2 稍微复杂点的例子:1234567891011121314151617181920212223242526public class User &#123; private String name; private Integer age; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public Integer getAge() &#123; return age; &#125;&#125;List&lt;User&gt; userList = Arrays.asList(new User(&quot;李四&quot;, 20), new User(&quot;张三&quot;, 18), new User(&quot;王五&quot;, 25));User user = userList.stream().filter(e -&gt; e.getAge() &gt; 25).findFirst().orElse(new User(&quot;王老五&quot;, 30));System.out.println(user.getName());result:王老五 orElseGet() 如果存在，返回原来的值，如果不存在，返回返回函数式接口的结果public T orElseGet(Supplier&lt;? extends T&gt; other)和orElse不同的是，这个可以传入一个函数表达式123456Optional&lt;Object&gt; emptyOptional = Optional.empty();String name = &quot;王老五&quot;;Object orElseGet = emptyOptional.orElseGet(name::length);System.out.println(orElseGet);result:3 orElseThrow 如果存在，返回原来的值，如果不存在，抛出一个指定的异常public T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X 123456Optional&lt;Object&gt; emptyOptional = Optional.empty();Object orElseThrow = emptyOptional.orElseThrow(()-&gt;new RuntimeException(&quot;程序异常&quot;));result:Exception in thread &quot;main&quot; java.lang.RuntimeException: 程序异常... filter() 按要求返回过滤后的元素，没有返回一个空的Optional对象public Optional filter(Predicate&lt;? super T&gt; predicate)1234567891011Optional&lt;Object&gt; optional = Optional.of(1);Optional&lt;Object&gt; emptyOptional = Optional.empty();Optional&lt;Object&gt; optionalO = optional.filter(e -&gt; e.equals(1));Optional&lt;Object&gt; optionalO1 = emptyOptional.filter(e -&gt; e.equals(1));System.out.println(optionalO);System.out.println(optionalO1);result: Optional[1] Optional.empty map() 对Optional中保存的值进行函数运算，并返回新的Optional,里面保存的值可以是任何类型12345User user = new User(&quot;李四&quot;, 20);Optional&lt;Integer&gt; optionalInteger = Optional.of(new User(&quot;李四&quot;, 20)).map(User::getAge);System.out.println(optionalInteger);result:Optional[20] flatMap() 和map(),区别在于，保存的只只能和调用方一样123456789101112User user = new User(&quot;李四&quot;, 20);Optional&lt;User&gt; user1 = userOptional.flatMap(e -&gt; &#123; if (e.getAge() &gt; 19) &#123; return Optional.of(new User(&quot;张三&quot;, 21)); &#125; else &#123; return Optional.of(new User(&quot;王五&quot;, 18)); &#125;&#125;);System.out.println(user1.get().getName());result:张三]]></content>
      <categories>
        <category>java8</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo+travis+阿里云oss持续集成个人博客]]></title>
    <url>%2Fother%2Fhexo%20travis%20%E9%98%BF%E9%87%8C%E4%BA%91oss%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2Findex.html</url>
    <content type="text"><![CDATA[这两天抽空用hexo搭建了一个静态博客，并且使用travis+github pages做持续集成。后来对github pages的响应速度不是很满意，便将博客换成了hexo+travis+oss。 实现的效果是只需要提交代码，便自动将博客更新到github pages 和oss上面。 使用hexo+travis+github pages 完成持续部署的过程不在赘述，网上有很多教程，不过质量参差不齐，这里推荐一篇：使用Travis CI自动部署Hexo博客 按照这篇文章操作，应该就可以实现hexo+travis+github pages持续集成。我在这个基础上，增加了对oss的持续集成。 有关oss如何部署静态页面，参考如何将 hexo 生成的博客部署至阿里云 OSS 并全站启用 CDN 加速访问 值得一提的是，如果需要将oss绑定到域名，需要备案。 接下来需要做的是在push代码的时候，将构建出来的静态文件上传到oss中。这里我使用的是阿里云oss提供的工具类：命令行工具ossutil 首先将ossutil下载，放到hexo源码根目录: 在上传只github pages的基础上，增加以下代码:1234567891011# 进入根目录cd ../# 开启权限chmod 755 ossutil64# 配置endpoint，id 秘钥./ossutil64 config -e &lt;your oss endpoint&gt; -i &lt;your AccessKey ID&gt; -k &lt;your Access Key Secret&gt;# 先删除所有文件，防止出现文件改名后不能覆盖的问题./ossutil64 rm oss://keji-blog-hexo -r -f# 上传public文件至oss./ossutil64 cp public oss://keji-blog-hexo/ -r -f --loglevel=debug 这样，便可以了。]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BigDecimal使用案例]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2FBigDecimal%2FBigDecimal%2Findex.html</url>
    <content type="text"><![CDATA[创建BigDecimal对象创建BigDecimal对象常用的方式有2种：12BigDecimal a = new Bigdecimal(1);BigDecimal a1 = BigDecimal.valueOf(1); 不推荐使用new 关键字创建Bigdecimal对象。原因是当new 的值是一个小数的时候，其真实的值并不是我们想要的值1234BigDecimal b = new BigDecimal(1.1);BigDecimal b1 = BigDecimal.valueOf(1.1);System.out.println("new的值b: "+b);System.out.println("valueOf()的值b1: "+b1); 输出:121.100000000000000088817841970012523233890533447265625valueOf()的值b1: 1.1 这在比较大小的时候，很可能出现意想不到的结果。 例如: 123BigDecimal a = new BigDecimal(1.1);String b = "1.1";System.out.println(a.toString().equals(b)); //fasle 如果不注意，很可能产生bug。 加法加法的方法有两种，方法签名如下:12public BigDecimal add(BigDecimal augend)public BigDecimal add(BigDecimal augend, MathContext mc) MathContext 用于指定精度和舍入模式，具体查看官方javadoc demo:12345678910111213BigDecimal a = BigDecimal.valueOf(1);BigDecimal b = BigDecimal.valueOf(1.5);BigDecimal c = BigDecimal.valueOf(1.4);BigDecimal addResult = a.add(b);BigDecimal addResult1 = a.add(b,new MathContext(2));BigDecimal addResult2 = a.add(b,new MathContext(1));BigDecimal addResult3 = a.add(c,new MathContext(1));System.out.println("addResult: "+addResult);System.out.println("addResult1: "+addResult1);System.out.println("addResult2: "+addResult2);System.out.println("addResult3: "+addResult3); result:1234addResult: 2.5addResult1: 2.5addResult2: 3addResult3: 2 mc 设置保留几位小数，舍入按四舍五入 减法方法签名如下：12public BigDecimal subtract(BigDecimal subtrahend)public BigDecimal subtract(BigDecimal subtrahend, MathContext mc) demo：12345678910111213BigDecimal a = BigDecimal.valueOf(1);BigDecimal b = BigDecimal.valueOf(1.5);BigDecimal c = BigDecimal.valueOf(1.4);BigDecimal subtract = a.subtract(b);BigDecimal subtract1 = a.subtract(b,new MathContext(2));BigDecimal subtract2 = a.subtract(b,new MathContext(1));BigDecimal subtract3 = a.subtract(c,new MathContext(1));System.out.println("subtract: "+subtract);System.out.println("subtract1: "+subtract1);System.out.println("subtract2: "+subtract2);System.out.println("subtract3: "+subtract3); result：1234subtract: -0.5subtract1: -0.5subtract2: -0.5subtract3: -0.4 乘法：方法签名:12public BigDecimal multiply(BigDecimal multiplicand)public BigDecimal multiply(BigDecimal multiplicand, MathContext mc) demo:12345678910111213BigDecimal a = BigDecimal.valueOf(1);BigDecimal b = BigDecimal.valueOf(1.5);BigDecimal c = BigDecimal.valueOf(1.4);BigDecimal multiply = a.multiply(b);BigDecimal multiply1 = a.multiply(b,new MathContext(2));BigDecimal multiply2 = a.multiply(b,new MathContext(1));BigDecimal multiply3 = a.multiply(c,new MathContext(1));System.out.println("multiply: "+multiply);System.out.println("multiply1: "+multiply1);System.out.println("multiply2: "+multiply2);System.out.println("multiply3: "+multiply3); result:1234multiply: 1.5multiply1: 1.5multiply2: 2multiply3: 1 除法:123456public BigDecimal divide(BigDecimal divisor)public BigDecimal divide(BigDecimal divisor, MathContext mc)public BigDecimal divide(BigDecimal divisor, int roundingMode)public BigDecimal divide(BigDecimal divisor, RoundingMode roundingMode)public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 其中 public BigDecimal divide(BigDecimal divisor) 不推荐使用。idea警告如下:123456Inspection info: Reports calls to divide() or setScale() without a rounding mode argument. Such calls can lead to an ArithmeticException when the exact value cannot be represented in the result (e.g. because it has a non-terminating decimal expansion). Specifying a rounding mode prevents the ArithmeticException.翻译:检查信息:报告调用divide()或setScale()，而不带舍入模式参数。当结果中不能表示精确值时，这种调用可能导致算术异常(例如，因为它具有无限的十进制展开)。指定舍入模式可以防止算术异常。简单点说就是除不尽的时候会报错 所以用除法的时候，我们需要指定其舍入模式。推荐使用:12public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 指定舍入模式，和保留几位小数 demo:12BigDecimal divide = a.divide(b, 2, BigDecimal.ROUND_HALF_UP);System.out.println("divide: "+divide);]]></content>
      <categories>
        <category>java基础</category>
        <category>BigDecimal</category>
      </categories>
  </entry>
</search>
