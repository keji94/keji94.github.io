<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis zset数据结构使用案例以及原理解析]]></title>
    <url>%2Fredis%2Fredis%20zset%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2Findex.html</url>
    <content type="text"><![CDATA[前言关于redis，我使用最多的数据结构就是简单的String。对于其他数据结构list、set、hash、zset，乃至于更高级的HyperLogLog、布隆过滤器，基本没有使用过，这次在工作中，恰好遇到需要使用zset的业务场景，特此记录。 zset数据结构介绍zset 可能是 Redis 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「跳跃列表」的数据结构。 zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。 zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。 zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。123456789101112131415161718192021222324252627282930313233&gt; zadd books 9.0 "think in java"(integer) 1&gt; zadd books 8.9 "java concurrency"(integer) 1&gt; zadd books 8.6 "java cookbook"(integer) 1&gt; zrange books 0 -1 # 按 score 排序列出，参数区间为排名范围1) "java cookbook"2) "java concurrency"3) "think in java"&gt; zrevrange books 0 -1 # 按 score 逆序列出，参数区间为排名范围1) "think in java"2) "java concurrency"3) "java cookbook"&gt; zcard books # 相当于 count()(integer) 3&gt; zscore books "java concurrency" # 获取指定 value 的 score"8.9000000000000004" # 内部 score 使用 double 类型进行存储，所以存在小数点精度问题&gt; zrank books "java concurrency" # 排名(integer) 1&gt; zrangebyscore books 0 8.91 # 根据分值区间遍历 zset1) "java cookbook"2) "java concurrency"&gt; zrangebyscore books -inf 8.91 withscores # 根据分值区间 (-∞, 8.91] 遍历 zset，同时返回分值。inf 代表 infinite，无穷大的意思。1) "java cookbook"2) "8.5999999999999996"3) "java concurrency"4) "8.9000000000000004"&gt; zrem books "java concurrency" # 删除 value(integer) 1&gt; zrange books 0 -11) "java cookbook"2) "think in java" 业务场景本次使用到zset的业务是一个挂号底部消息通知的需求。当用户在微脉app上面挂号之后，就诊日期前两天时在底部出现消息提示，提示用户挂号信息，对用户进行引导。 这里只是简单的描述，实际需求比这个复杂很多。完成这个需求的第一步，便是获取用户的预约挂号记录。预约挂号秒的数据量很大，接近1000w，如果每次请求都去查库，势必对数据库造成很大压力。在查询完数据之后放入缓存，可以减缓数据库压力。但是app在推送咨询之后，流量会瞬间暴涨，如果这个时候没有缓存，流量瞬间到了数据库，很有可能造成数据库堵塞，甚至假死。 总之，需要避免app请求这个接口的时候直接去查库，只从redis中取数据，这就需要提前将数据放入缓存。当时考虑的方案有两个，一个是用调度在凌晨将最近3天的预约挂号记录查询出来，放入缓存。一个是当用户产生挂号业务(挂号，取消挂号等)时，发送消息异步更新缓存数据。 第一个方式简单粗暴，改动量小，不过还是要查询数据库，扫表。第二个方式改动量较大，但是不会对数据库造成压力。 综合考虑之后，我们选择了第二种。 redis数据结构的选择不管使用哪一种方案，都需要将用户的挂号信息放入redis，那么使用哪一种数据结构呢？。直接使用简单的String结构，一个挂号信息对应一条redis的key-value，现在我们每天的挂号量有几万，3天大概就是十几万的key，在可以接受的范围内，不过随着业务的发展，key的数量可能会暴涨，不是很好，后面还要优化。 这个时候想到了redis的zset数据结构，一个用户对应一个key，使用就诊日期的时间戳作为score，取的使用使用score取出数据。完全满足这个需求。 附上接受到挂号消息业务之后的伪代码: 12345678910//根据主键查询预约挂号信息MzgyMenZhenYYEntity entity = getRegistrationEntity(registrationId);//根据预约挂号的客户编号生成redis keyString key = GeneratorRedisKeyUtil.createRegistrationKey(entity.getYuyuekhbh());//根据就诊日期计算scorelong score = getScore(entity.getYuyuejzrq());//计算key的过期时间，始终保持key的过期时间在最大就诊日期之后long expireSecond = getExpireSecond(entity.getYuyuejzrq(), key);//放入redisredisClient.zadd(key, (double)score, JSON.toJSONString(convertEntity2DTO(entity)), (int)expireSecond); 取数据的伪代码: 123456789101112131415161718//根据主键查询预约挂号信息String key = GeneratorRedisKeyUtil.createRegistrationKey(customerId);Date now = new Date();//计算startScoreDate start = DateUtil.getSpecialDayStartTime(new Date());//计算endScoreDate end = DateUtil.getSpecialDayEndTime(DateUtil.plusDay(now, 2L));//根据score从redis取数据Set&lt;String&gt; set = redisClient.zrangeByScore(key, start.getTime(), end.getTime());//转换为出参需要的数据结构List&lt;RegistrationInfoDTO&gt; list = new ArrayList&lt;&gt;(set.size());for (String json : set) &#123; list.add(JSON.parseObject(json, RegistrationInfoDTO.class));&#125;return list; zset底层原理以下内容节选至老钱的《Redis深度历险:核心原理与应用》 侵删 zset 内部的排序功能是通过「跳跃列表」数据结构来实现的，它的结构非常特殊，也比较复杂。 因为 zset 要支持随机的插入和删除，所以它不好使用数组来表示。我们先看一个普通的链表结构。 我们需要这个链表按照 score 值进行排序。这意味着当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？ 想想一个创业公司，刚开始只有几个人，团队成员之间人人平等，都是联合创始人。随着公司的成长，人数渐渐变多，团队沟通成本随之增加。这时候就会引入组长制，对团队进行划分。每个团队会有一个组长。开会的时候分团队进行，多个组长之间还会有自己的会议安排。公司规模进一步扩展，需要再增加一个层级 —— 部门，每个部门会从组长列表中推选出一个代表来作为部长。部长们之间还会有自己的高层会议安排。 跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。 想想你老家在世界地图中的位置：亚洲–&gt;中国-&gt;安徽省-&gt;安庆市-&gt;枞阳县-&gt;汤沟镇-&gt;田间村-&gt;xxxx号，也是这样一个类似的结构。 「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，同时处于 L0、L1 和 L2 层，可以快速在不同层次之间进行「跳跃」。 定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问，那新插入的元素如何才有机会「身兼数职」呢？ 跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。 首先 L0 层肯定是 100% 了，L1 层只有 50% 的概率，L2 层只有 25% 的概率，L3 层只有 12.5% 的概率，一直随机到最顶层 L31 层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。 这还挺公平的，能不能进入中央不是靠拼爹，而是看运气。 关于跳跃列表的内部结构实现，请阅读第 36 节凌波微步 —— 探索「跳跃列表」内部结构]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO模型]]></title>
    <url>%2Funcategorized%2FJava-IO%E6%A8%A1%E5%9E%8B%2Findex.html</url>
    <content type="text"><![CDATA[Linux系统的五种IO模式Java 的 IO 模型本质上还是利用操作系统提供的接口来实现,所以最好先了解Linux底层模型。推荐阅读Linux IO模式及 select、poll、epoll详解 Java IO模型的演变BIO在JDK1.4之前，基于Java的所有Socket通信都采用同步阻塞模式(BIO)，这种一请求一应答的通信模型简化了上层的应用开发，但是在性能和可靠性方面却存在着巨大的瓶颈。当并发量增大，响应时间延迟增大之后，采用Java BIO开发的服务端只有通过硬件的不断扩容来满足高并发和低延迟，它极大的增加了企业的成本，随着集群规模的不断膨胀，系统的可维护性也面临巨大的挑战。 代码类似这样: 12345678910111213141516171819202122232425262728293031323334353637public class BlokingIoServer implements Runnable&#123; @Override public void run() &#123; try &#123; //将服务绑定到指定端口 ServerSocket ss = new ServerSocket(8888); while (!Thread.interrupted())&#123; //对 accept()方法的调 用将被阻塞，直到一个连接建立 final Socket clientSocket = ss.accept(); //为每个请求创建一个线程来处理 new Thread(new Handler(clientSocket)).start(); &#125; // or, single-threaded, or a thread pool &#125; catch (IOException ex) &#123; /* ... */ &#125; &#125; static class Handler implements Runnable &#123; final Socket socket; Handler(Socket s)&#123; socket = s; &#125; @Override public void run() &#123; try &#123; byte[] input = new byte[1024]; socket.getInputStream().read(input); byte[] output = process(input); socket.getOutputStream().write(output); &#125; catch (IOException ex) &#123; /* ... */ &#125; &#125; private byte[] process(byte[] cmd)&#123; //do something return null; &#125; &#125;&#125; Web服务，大多数有着类似的流程:Read request (从底层IO读取网络字节请求)Decode request (把读取的网络字节请求进行解码,封装成为业务请求对象)Process service (对解码封装后的业务请求对象进行业务处理)Encode reply (将业务逻辑处理完后的响应进行编码为底层IO可传输的字节响应)Send reply (利用底层IO发送已编码的字节响应) 不同之处在于，每一个步骤底层使用的技术和手段不同，比如:XML解析,文件传输,Web页面生成,计算服务….. 经典(传统)的网络服务设计如上图所示，对每个请求都会产生一个新的线程来进行处理，这种设计的缺点是，线程的创建本身是系统资源的一个开销，如果并发请求达到一定数量，响应将会变慢，甚至有可能因为系统资源不足而造成系统崩溃。 伪异步I/O编程为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化，后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M:线程池最大线程数N的比例关系，其中M可以远远大于N,通过线程池可以灵活的调配线程资源， 设置线程的最大值， 防止由于海量并发接入导致线程耗尽。 当有新的客户端接入的吋候，将客户端的Socket封装成一个Task （该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃线程对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class TimeServer &#123; public static void main(String[] args) throws IOException &#123; int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; try &#123; port = Integer.valueOf(args[0]); &#125; catch (NumberFormatException e) &#123; //采用默汄值 &#125; &#125; ServerSocket server = null; try &#123; server = new ServerSocket(port); System.out.println("The time server is start in port :" + port); Socket socket = null; TimeServerHandlerExecutePool singleExecutor = new TimeServerHandlerExecutePool(50, 10000); while (true) &#123; socket = server.accept(); singleExecutor.execute(new TimeServerHandler(socket)); &#125; &#125; finally &#123; if (server != null) &#123; System.out.println("The time server close11"); server.close(); server = null; &#125; &#125; &#125;&#125;public class TimeServerHandlerExecutePool &#123; private ExecutorService executor; public TimeServerHandlerExecutePool(int maxPoolSize, int queueSize) &#123; executor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors(), maxPoolSize, 120L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize)); &#125; public void execute(java.lang.Runnable task) &#123; executor.execute(task); &#125;&#125;public class TimeServerHandler implements Runnable &#123; private Socket socket; public TimeServerHandler(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; BufferedReader in = null; PrintWriter out = null; try &#123; in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); out = new PrintWriter(this.socket.getOutputStream(), true); String currentTime = null; String body = null; while (true) &#123; body = in.readLine(); if (body == null) &#123; break; &#125; System.out.println("The time server receive order : " + body); currentTime = "QUERY TIME ORDER".equalsIgnoreCase(body) ? new Date(System.currentTimeMillis()) .toString() : "BAD ORDER"; System.out.println(currentTime); &#125; &#125; catch (Exception e) &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException el) &#123; el.printStackTrace(); &#125; if (out != null) &#123; out.close(); out = null; &#125; if (this.socket != null) &#123; try &#123; this.socket.close(); &#125; catch (IOException el) &#123; el.printStackTrace(); &#125; this.socket = null; &#125; &#125; &#125; &#125;&#125; 伪异步IO解决了线程的频繁创建销毁问题，但是如果通信对方返回应答时间过长，会引起级联故障，比如下面的场景: 服务端处理缓慢，返回应答消息耗费60s，平时只需要10ms。 采用伪异步IO的线程正在读取故障服务节点的响应，由于读取输入流是阻塞的，因此，它将会被同步阻塞60s。 假如所有的可用线程都被故障服务器阻塞，那后续所有的IO消息都将在队列中排队。 由于线程池采用阻塞队列实现，将队列积满之后，后续入队列的操作将被阻塞。 由于前段只有一个Accptor线程接口客户端接入，它被阻塞在线程池的同步阻塞队列之后，新的客户端请求消息将被拒绝，客户端会发生大量的连接超时。 由于几乎所有的连接都超时，调用者会认为系统崩溃，无法接受新的请求消息。 NIONIO，有人解释为new I/O,有人解释为Non-block I/O(我更倾向后者)。 正是由于Java传统BIO的拙劣表现，才使得Java支持非阻塞I/O的呼声日渐高涨，最终，JDK1.4版本提供了新的NIO类库，Java终于也可以支持非阻塞I/O 了。NIO主要的类和接口如下: 进行异步I/O操作的缓冲区ByteBuffer等; 进行异步I/O操作的管道Pipe； 进行各种I/O操作（异步或者同步）的Channel,包括ServerSocketChannel和 SocketChannel： 多种字符集的编码能力和解码能力； 实现非阻塞I/O操作的多路复用器selector： 基千流行的Perl实现的正则表达式类库； 文件通道FileChannelo。 新的NIO类库的提供，极大地促进了基于Java的异步非阻塞编程的发展和应用，但是，它依然有不完善的地方，特别是对文件系统的处理能力仍显不足，主要问题如下。 没有统一的文件属性（例如读写权限）； API能力比较弱，例如目录的级联创建和递归遍历，往往需要自己实现： 底层存储系统的一些高级API无法使用： 所有的文件操作都是同步阻塞调用，不支持异步文件读写操作。 2011年7月28日，JDKI.7正式发布。她将原来的NIO类库进行了升级，被称为NIO2.0。它主要提供了如下三个方面的改进。 能够提供能够批量获取文件属性的API，这些API具有平台无关性，不与特定的文件系统相耦合，另外它还提供了标准文件系统的SPI,供各个服务提供商扩展实现； 提供AIO功能，支持基于文件的异步I/O操作和针对网络套接字的异步操作； 完成JSR-5I定义的通道功能，包括对配置和多播数据报的支持等； NIO类库概念和功能介绍缓冲区BufferBuffer是一个对象，它包含一些要写入或者要读出的数据。在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，写入到缓冲区中。任何吋候访问NIO中的数据，都是通过缓冲区进行操作。 缓冲区实质上是一个数组。通常它是一个字节数组(ByteBuffer),也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置(limit)等信息。 最常用的缓冲区是ByteBuffer, 一个ByteBuffer提供了一组功能用于操作byte数组。除了 ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型(除了 Boolean类型)都对应有一种缓冲区，具体如下。 ByteBuffer：字节缓冲区 CharBuffer：字符缓冲区 ShortBuffer：短整型缓冲K IntBuffer：整形缓冲区 LongBuffer：长整形缓冲区 FloatBuffer：浮点型缓冲区 DoubleBuffer： 双精度浮点型缓冲区 每—个Buffer类都是Buffer接口的一个T实例。除了 ByteBuffer,每一个Buffe类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准I/O操作都使用ByteBuffer,所以它除了具有一般缓冲区的操作之外还提供一些特有的操作，方便网络读写。 管道channelChannel是一个通道，可以通过它读取和写入数据，它就像自来水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，流只是在一个方向上移动（一个流必须是InputStream或者OutputStream的子类），而且通道可以用于读、写或者同时用于读写。 Channel的类继承图如下。 因为Channel是全双工的，所以它可以比流更好地映射底层操作系统的API。特别是在UNIX网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。 多路复用器Selector多路复用器提供选择已经就绪的任务的能力。 简单来讲， Selector会不断地轮询注册在其上的Channel,如果某个Channel上面有新的TCP 连接接入、 读和写事件， 这个Channel就处于就绪状态， 会被Selector轮询出来， 然后通过SelectionKey可以获取就绪Channel的集合， 进行后续的I/O操作。 使用NIO实现服务端 123456789101112131415161718192021public class TimeServerNio &#123; public static void main(String[] args) &#123; //设置监听端口 int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; try &#123; port = Integer.valueOf(args[0]); &#125; catch (NumberFormatException e) &#123; //采用默认值 &#125; &#125; //创建了一个被称为MultiplexerTimeServer的多路复用类， 它是个一个独立 //的线程， 负责轮洵多路复用器Selctor,可以处理多个客户端的并发接入 MultiplexerTimeServer timeServer = new MultiplexerTimeServer(port); new Thread(timeServer, "NIO-MultiplexerTirneServer-001H").start(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public class MultiplexerTimeServer implements Runnable &#123; private Selector selector; private ServerSocketChannel servChannel; private volatile boolean stop; /** * 在构造方法中进行资源初始化， 创建多路复用器Selector、 * ServerSocketChannel,对 Channel 和 TCP 参数进行配置 * * @param port */ public MultiplexerTimeServer(int port) &#123; try &#123; selector = Selector.open(); servChannel = ServerSocketChannel.open(); //设置为异步非阻塞模式 servChannel.configureBlocking(false); servChannel.socket().bind(new InetSocketAddress(port), 1024); //注册selector servChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println("The time server is start in port : " + port); &#125; catch (IOException e) &#123; //资源初始化失败，退出系统 e.printStackTrace(); System.exit(1); &#125; &#125; public void stop() &#123; this.stop = true; &#125; @Override public void run() &#123; while (!stop) &#123; try &#123; //循环遍历selector,它的休眠时间为1s selector.select(1000); //返回就绪状态的Channel的SelectionKey集合 Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator(); SelectionKey key = null; //通过对就绪状态的Channel集合进行迭代， 可以进行网络的异步读写操作 while (it.hasNext()) &#123; key = it.next(); it.remove(); try &#123; handleInput(key); &#125; catch (Exception e) &#123; if (key != null) &#123; key.cancel(); if (key.channel() != null) &#123; key.channel().close(); &#125; &#125; &#125; &#125; &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源 if (selector != null) &#123; try &#123; selector.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void handleInput(SelectionKey key) throws IOException &#123; if (key.isValid()) &#123; // 处理新接入的请求消息 if (key.isAcceptable()) &#123; // Accept the new connection ServerSocketChannel ssc = (ServerSocketChannel) key.channel(); SocketChannel sc = ssc.accept(); sc.configureBlocking(false); // Add the new connection to the selector sc.register(selector, SelectionKey.OP_READ); &#125; if (key.isReadable()) &#123; // Read the data SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer readBuffer = ByteBuffer.allocate(1024); int readBytes = sc.read(readBuffer); if (readBytes &gt; 0) &#123; readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String body = new String(bytes, "UTF-8"); System.out.println("The time server receive order : " + body); String currentTime = "QUERY TIME ORDER" .equalsIgnoreCase(body) ? new java.util.Date( System.currentTimeMillis()).toString() : "BAD ORDER"; doWrite(sc, currentTime); &#125; else if (readBytes &lt; 0) &#123; // 对端链路关闭 key.cancel(); sc.close(); &#125; else &#123; ; // 读到0字节，忽略 &#125; &#125; &#125; &#125; /** * 将应答消息异步发送给客户端 * * @param channel channel * @param response response * @throws IOException exception */ private void doWrite(SocketChannel channel, String response) throws IOException &#123; if (response != null &amp;&amp; response.trim().length() &gt; 0) &#123; //将字符串编码成字节数组， 根据字节数组的容量创建ByteBuff byte[] bytes = response.getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length); //将字节数据复制到缓冲区 writeBuffer.put(bytes); writeBuffer.flip(); //将缓冲区中的字节数组发送出去 channel.write(writeBuffer); &#125; &#125;&#125; 使用NIO实现客户端 12345678910111213141516public class TimeClientNio &#123; public static void main(String[] args) &#123; int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; try &#123; port = Integer.valueOf(args[0]); &#125; catch (NumberFormatException e) &#123; // 采用默认值 &#125; &#125; new Thread(new TimeClientHandle("127.0.0.1", port), "TimeClient-001") .start(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class TimeClientHandle implements Runnable&#123; private String host; private int port; private Selector selector; private SocketChannel socketChannel; private volatile boolean stop; /** * implements Runnable * * @param host host * @param port port */ public TimeClientHandle(String host, int port) &#123; this.host = host == null ? "127.0.0.1" : host; this.port = port; try &#123; selector = Selector.open(); socketChannel = SocketChannel.open(); //设置为异步非阻塞模式 socketChannel.configureBlocking(false); &#125; catch (IOException e) &#123; e.printStackTrace(); System.exit(1); &#125; &#125; @Override public void run() &#123; try &#123; //发送连接请求 doConnect(); &#125; catch (IOException e) &#123; e.printStackTrace(); System.exit(1); &#125; while (!stop) &#123; try &#123; selector.select(1000); Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator(); SelectionKey key = null; while (it.hasNext()) &#123; key = it.next(); it.remove(); try &#123; handleInput(key); &#125; catch (Exception e) &#123; if (key != null) &#123; key.cancel(); if (key.channel() != null) key.channel().close(); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); System.exit(1); &#125; &#125; // 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源 if (selector != null)&#123; try &#123; selector.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void handleInput(SelectionKey key) throws IOException &#123; if (key.isValid()) &#123; // 判断是否连接成功 SocketChannel sc = (SocketChannel) key.channel(); //如果返回值为true,说明客户端连接成功 if (key.isConnectable()) &#123; if (sc.finishConnect()) &#123; sc.register(selector, SelectionKey.OP_READ); doWrite(sc); &#125; else &#123; System.exit(1);// 连接失败，进程退出 &#125; &#125; if (key.isReadable()) &#123; //预分配1M的接收缓冲K用于读取应答消息， 调川Socketchannel的read()方法进行异步读取操作 ByteBuffer readBuffer = ByteBuffer.allocate(1024); int readBytes = sc.read(readBuffer); if (readBytes &gt; 0) &#123; readBuffer.flip(); byte[] bytes = new byte[readBuffer.remaining()]; readBuffer.get(bytes); String body = new String(bytes, "UTF-8"); System.out.println("Now is : " + body); this.stop = true; &#125; else if (readBytes &lt; 0) &#123; // 对端链路关闭 key.cancel(); sc.close(); &#125; else ; // 读到0字节，忽略 &#125; &#125; &#125; private void doConnect() throws IOException &#123; // 如果直接连接成功，则注册到多路复用器上，发送请求消息，读应答 if (socketChannel.connect(new InetSocketAddress(host, port))) &#123; socketChannel.register(selector, SelectionKey.OP_READ); doWrite(socketChannel); &#125; else &#123; //如果没有直接连接成功， 则说明服务端没有返回TCP握手应答消息， 但这并不代表连接失败， 我们需要将SocketChannel //注册到多路复用器Selector上， 注册SelectionKey.OP CONNECT»当服务端返回TCP //syn-ack消息后， Selector就能够轮询到这个SocketChannel处于连接就绪状态 socketChannel.register(selector, SelectionKey.OP_CONNECT); &#125; &#125; private void doWrite(SocketChannel sc) throws IOException &#123; byte[] req = "QUERY TIME ORDER".getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(req.length); writeBuffer.put(req); writeBuffer.flip(); sc.write(writeBuffer); //hasRemaining()方法对发送结果进行判断， 是否全部发送完成 if (!writeBuffer.hasRemaining()) &#123; System.out.println("Send order 2 server succeed."); &#125; &#125;&#125; NIO编程难度确实比同步阻塞BIO大很多， 上面的NIO 例子并没有考虑“ 半包读” 和“ 半包写” ， 如果加上这些， 代码将会更加复杂。 NIO优点总结 客户端发起的连接操作是异步的， 可以通过在多路复用器注册OP_CONNECT等待后续结果， 不需要像之前的客户端那样被同步阻塞。 Socketchannel的读写操作都是异步的， 如果没有可读写的数据它不会同步等待，直接返回， 这样I/O通信线程就可以处理其他的链路， 不需要同步等待这个链路可用。 线程模型的优化： 由于JDK的Selector在Linux等主流操作系统上通过epoll实现， 它没有连接句柄数的限制(只受限于操作系统的最大句柄数或者对单个进程的句柄限制)， 这意味着一个Selector线程可以同时处理成千上万个客户端连接， 而且性能不会随着客户端的增加而线性下降， 因此， 它非常适合做高性能、 高负载的网络服务器。 AIONIO2.0引入了新的异步通道概念，并提供了异步文件通道和异步套接字通道的实现。异步通道提供两种方式获取操作结果. 通过java.util.concurrent.Future类來表示异步操作的结果； 在执行异步操作的时候传入一个java.nio.channels。 CompletionHandler接口的实现类作为操作完成的回调。 NIO2.0的异步套接字通道是真正的异步非阻塞I/O,它对应UNIX网络编程中的事件驱动I/O (AIO),它不需要通过多路复用器(Selector)对注册的通道进行轮询操作即可实现异步读写， 从而简化了 NIO的编程模型。 aio服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public class TimeServerAio &#123; public static void main(String[] args) throws IOException &#123; int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; try &#123; port = Integer.valueOf(args[0]); &#125; catch (NumberFormatException e) &#123; // 采用默认值 &#125; &#125; //创建异步的时间服务器处理类 AsyncTimeServerHandler timeServer = new AsyncTimeServerHandler(port); new Thread(timeServer, "AIO-AsyncTimeServerHandler-001").start(); &#125;&#125;public class AsyncTimeServerHandler implements Runnable&#123; private int port; CountDownLatch latch; AsynchronousServerSocketChannel asynchronousServerSocketChannel; /** * 创建一个异步的服务端通道AsynchronousServerSocketChannel， 然后调H］它的 * bind h'法绑定监听端口， 如果端口合法且没被占用， 绑定成功， 打印启动成功提示到控 * 制台 * * @param port port */ public AsyncTimeServerHandler(int port) &#123; this.port = port; try &#123; asynchronousServerSocketChannel = AsynchronousServerSocketChannel .open(); asynchronousServerSocketChannel.bind(new InetSocketAddress(port)); System.out.println("The time server is start in port : " + port); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; //初始化CountDownLatch对象， 它的作用是在完成一组正在执行的操作之前， 允许当前的线程一直阻塞.在本例程中， 我们让线程在此阻塞, //防止服务端执行完成退出。 在实际项目应用中， 不需要启动独立的线程來处理 //AsynchronousServerSocketChannel latch = new CountDownLatch(1); doAccept(); try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void doAccept() &#123; //接收客户端的选接 asynchronousServerSocketChannel.accept(this, new AcceptCompletionHandler()); &#125;&#125;public class AcceptCompletionHandler implements CompletionHandler&lt;AsynchronousSocketChannel, AsyncTimeServerHandler&gt; &#123; @Override public void completed(AsynchronousSocketChannel result, AsyncTimeServerHandler attachment) &#123; attachment.asynchronousServerSocketChannel.accept(attachment, this); ByteBuffer buffer = ByteBuffer.allocate(1024); result.read(buffer, buffer, new ReadCompletionHandler(result)); &#125; @Override public void failed(Throwable exc, AsyncTimeServerHandler attachment) &#123; exc.printStackTrace(); attachment.latch.countDown(); &#125;&#125;public class ReadCompletionHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123; private AsynchronousSocketChannel channel; public ReadCompletionHandler(AsynchronousSocketChannel channel) &#123; if (this.channel == null) &#123; this.channel = channel; &#125; &#125; @Override public void completed(Integer result, ByteBuffer attachment) &#123; attachment.flip(); byte[] body = new byte[attachment.remaining()]; attachment.get(body); try &#123; String req = new String(body, "UTF-8"); System.out.println("The time server receive order : " + req); String currentTime = "QUERY TIME ORDER".equalsIgnoreCase(req) ? new java.util.Date( System.currentTimeMillis()).toString() : "BAD ORDER"; doWrite(currentTime); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; private void doWrite(String currentTime) &#123; if (currentTime != null &amp;&amp; currentTime.trim().length() &gt; 0) &#123; byte[] bytes = (currentTime).getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length); writeBuffer.put(bytes); writeBuffer.flip(); channel.write(writeBuffer, writeBuffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer buffer) &#123; // 如果没有发送完成，继续发送 if (buffer.hasRemaining()) &#123; channel.write(buffer, buffer, this); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; channel.close(); &#125; catch (IOException e) &#123; // ingnore on close &#125; &#125; &#125;); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; this.channel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; aio客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class TimeClientAio &#123; public static void main(String[] args) &#123; int port = 8080; if (args != null &amp;&amp; args.length &gt; 0) &#123; try &#123; port = Integer.valueOf(args[0]); &#125; catch (NumberFormatException e) &#123; // 采用默认值 &#125; &#125; new Thread(new AsyncTimeClientHandler("127.0.0.1", port), "AIO-AsyncTimeClientHandler-001").start(); &#125;&#125;public class AsyncTimeClientHandler implements CompletionHandler&lt;Void, AsyncTimeClientHandler&gt;, Runnable&#123; private AsynchronousSocketChannel client; private String host; private int port; private CountDownLatch latch; public AsyncTimeClientHandler(String host, int port) &#123; this.host = host; this.port = port; try &#123; client = AsynchronousSocketChannel.open(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; latch = new CountDownLatch(1); client.connect(new InetSocketAddress(host, port), this, this); try &#123; latch.await(); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void completed(Void result, AsyncTimeClientHandler attachment) &#123; byte[] req = "QUERY TIME ORDER".getBytes(); ByteBuffer writeBuffer = ByteBuffer.allocate(req.length); writeBuffer.put(req); writeBuffer.flip(); client.write(writeBuffer, writeBuffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer buffer) &#123; if (buffer.hasRemaining()) &#123; client.write(buffer, buffer, this); &#125; else &#123; ByteBuffer readBuffer = ByteBuffer.allocate(1024); client.read( readBuffer, readBuffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer buffer) &#123; buffer.flip(); byte[] bytes = new byte[buffer .remaining()]; buffer.get(bytes); String body; try &#123; body = new String(bytes, "UTF-8"); System.out.println("Now is : " + body); latch.countDown(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; client.close(); latch.countDown(); &#125; catch (IOException e) &#123; // ingnore on close &#125; &#125; &#125;); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; try &#123; client.close(); latch.countDown(); &#125; catch (IOException e) &#123; // ingnore on close &#125; &#125; &#125;); &#125; @Override public void failed(Throwable exc, AsyncTimeClientHandler attachment) &#123; exc.printStackTrace(); try &#123; client.close(); latch.countDown(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 异步Socket Channel是被动执行对象， 我们不需要像 NIO编程那样创建一个独立的 I/O线程来处理读写操作。 对于AsynchronousServerSocketChannel和AsynchronousSocketChannel,它们都由JDK底层的线程池负责回调并驱动读写操作 #4中IO模型功能和特性对比]]></content>
  </entry>
  <entry>
    <title><![CDATA[==，equals，hashCode的区别和联系]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2Fequals%2F%3D%3D%EF%BC%8Cequals%EF%BC%8ChashCode%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%2Findex.html</url>
    <content type="text"><![CDATA[== 和equals== 比较的是对象在内存的地址。equals()定义在Object中。123public boolean equals(Object obj) &#123; return (this == obj);&#125; 这意味着所有对象都有equals()方法,并且默认情况下equals()方法和==一样比较的是对象在内存的地址值。一般引用数据类型之间的比较，需要重写equals，让其比较对象的字段值。 hashCode()方法的作用1public native int hashCode(); hashCode()方法注释翻译: 返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。 hashCode的的常规协定是: 在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据equals(Object)方法两个对象相等，那么对两个对象调用hashCode方法必须产生相同的整数结果。 如果两个对象根据equals(java.lang.Object)方法是不相等的，那么调用这两个对象上的hashCode方法必须产生不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同的整数结果可能会提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） 注意这一句话： “支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。” 也就是说，虽然每个Java类都包含hashCode() 函数。但是，仅仅当创建并某个“类的散列表”时(比如HashMap)，该类的hashCode() 才有用(作用是：确定该类的每一个对象在散列表中的位置)；其它情况下(例如，创建类的单个对象，或者创建类的对象数组等等)，类的hashCode() 没有作用。 上面的散列表，指的是：Java集合中底层是散列表的类，如HashMap，Hashtable，HashSet。 关于散列表更过详细的介绍，可以参考哈希表、Java中HashMap equals()和hashCode()的区别和联系面试的时候，经常会被问到，为什么重写equals方法的时候需要重写hashCode()？我们来看一个只重写equals的demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.HashSet;import java.util.Objects;import org.apache.commons.lang3.builder.ToStringBuilder;import org.apache.commons.lang3.builder.ToStringStyle;/** * * @author keji * @version $Id: HashCodeAndEquals.java, v 0.1 2018/12/12 6:40 PM keji Exp $ */public class HashCodeAndEquals &#123; public static void main(String[] args) &#123; User p1 = new User(100,"eee"); User p2 = new User(100,"eee"); User p3 = new User(200,"aaa"); HashSet&lt;User&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(p1); hashSet.add(p2); hashSet.add(p3); System.out.printf("p1.equals(p2) : %s; p1(%d) p2(%d)\n", p1.equals(p2), p1.hashCode(), p2.hashCode()); System.out.printf("set:%s\n", hashSet); &#125; private static class User&#123; private int age; private String name; public User(int age, String name) &#123; this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; User user = (User)o; return age == user.age &amp;&amp; Objects.equals(name, user.name); &#125; @Override public String toString() &#123; return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE); &#125; &#125;&#125;输出结果:p1.equals(p2) : true; p1(189568618) p2(793589513)set:[HashCodeAndEquals.User[age=100,name=eee], HashCodeAndEquals.User[age=100,name=eee], HashCodeAndEquals.User[age=200,name=aaa]] 可以看到，在只重写equals，没有重写hashcode的情况下。equals相等，但是hashcode不相等，导致HashSet中仍然有重复元素：p1和p2。 当在原来的基础上，重写HashCode，再次执行main()12345678@Overridepublic int hashCode() &#123; return Objects.hash(age, name);&#125;输出结果如下：p1.equals(p2) : true; p1(104354) p2(104354)set:[HashCodeAndEquals.User[age=100,name=eee], HashCodeAndEquals.User[age=200,name=aaa]] 所有，当我们在HashMap,HashTable,HashSet等这些底层使用散列表的数据结构时，如果我们只重写equals()而不重写hashCode()，并不能很好的利用他们的特性。 但是，当我们明确对象不会再HashMap,HashTable,HashSet等这些数据结构中使用时，我们不重写hashCode()写是可以的。1234567891011121314151617181920User p1 = new User(100,"eee");User p2 = new User(100,"eee");User p3 = new User(200,"aaa");ArrayList&lt;User&gt; list1 = new ArrayList&lt;&gt;();list1.add(p1);list1.add(p2);list1.add(p3);ArrayList&lt;User&gt; list2 = new ArrayList&lt;&gt;();list2.add(p1);list2.add(p2);list2.add(p3);System.out.printf("p1.equals(p2) : %s; p1(%d) p2(%d)\n", p1.equals(p2), p1.hashCode(), p2.hashCode());System.out.printf("p1.equals(p3) : %s; p1(%d) p3(%d)\n", p1.equals(p3), p1.hashCode(), p3.hashCode());System.out.printf("list1.equals(list2) :%s\n",list1.equals(list2));输出结果：p1.equals(p2) : true; p1(104354) p2(104354)p1.equals(p3) : false; p1(104354) p3(103482)list1.equals(list2) :true 关于HashCode和equals的区别和联系，网络上有这样一个结论:当equals相等时,HashCode一定相等。当HashCode相等时，equals不一定相等。 这个结论不能说它是错的，但是它有一个前提是对equals和hashCode()进行了重写。 重写equals的同时重写hashCode(反之亦然)，这是一种规范。虽然前面说过如果对象不存储在HashMap、HashSet、HashTab等这些对象中时，hashCode是无用的，但是谁敢在设计这个对象的时候保证该对象以后不会再这些数据结构中使用？ 综上所述，重写equals的时候，要重写hashCode方法。]]></content>
      <categories>
        <category>java基础</category>
        <category>equals</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java集合之ArrayList 源码解析]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2F%E9%9B%86%E5%90%88%2FArrayList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2Findex.html</url>
    <content type="text"><![CDATA[ArrayList是Java最常用的几种数据结构之一， 同时也是面试热点。了解其内部实现原理是非常必要的。 创建ArrayList123ArrayList&lt;Object&gt; list1 = new ArrayList&lt;&gt;();ArrayList&lt;Object&gt; list2 = new ArrayList&lt;&gt;(16);ArrayList&lt;Object&gt; list3 = new ArrayList&lt;&gt;(list2); ArrayList为我们提供了三个构造方法。我们创建ArrayList对象除了使用空参构造，还可以传递一个int数值，指定初始容量或者传递一个集合。 空参构造ArrayList()123456/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 空参构造非常简单，它会为我们创建一个空的集合。elementData成员变量是用来存放数据的对象,是一个Object[]，DEFAULTCAPACITY_EMPTY_ELEMENTDATA则是一个空的数组。 123456/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 注意DEFAULTCAPACITY_EMPTY_ELEMENTDATA类型为static final，表明其在内存中只有一份且禁止修改。 1234567/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access 注意elementData使用transient修饰。表明在采用Java默认的序列化机制的时候，被该关键字修饰的属性不会被序列化。而ArrayList类实现了java.io.Serializable接口，即采用了Java默认的序列化机制。但是elementData在网络传输的时候不序列化肯定是不行的，翻看源码会发现ArrayList自己实现了序列化和反序列化的方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 空参构造底层为我们创建的是一个空的数组，初始容量是0，这肯定没法存东西的，必然会使用的时候进行扩容。我们来看下add()方法1234567891011/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 首先，调用了ensureCapacityInternal()方法，入参传递了size+1，size+1表示elementData所需要的最小长度。这里的size变量，是用来记录ArrayList包含元素的多少的，初始值为0，我们调用ArrayList的size()方法，返回的就是该字段。123456/** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size; 看下ensureCapacityInternal()的源码:123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125; 简单点说，该方法做了一件事情，判断当前数组能不能方法即将被添加的元素，如果不能，扩容。 首先调用了calculateCapacity()计算容量，代码如下:123456private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; 如果集合还没有被初始化，则初始化容量为10。如果已经初始化过了，直接返回。1234/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10; 调用完calculateCapacity()后，调用ensureExplicitCapacity(),这个方法做了两件事情：1.将modCount自增2.如果容量不够，扩容。12345678private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //扩容 grow(minCapacity);&#125; 我们先将modCount属性放到一边，看下扩容的方法grow()。 1234567891011121314151617/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 可以看到扩容后的容量为原容量的1.5倍+1。另外网上很多文章说ArrayList是无限扩容的，其实不是，它是有限度的。上面的代码有一个判断:12if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); 如果扩容后的容量比数组最大容量大，调用hugeCapacity()方法，并将扩容前所需要的最小容量传递的进去。1234567private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; hugeCapacity方法只在扩容时可能被调用，它的逻辑很简单，先做了个简单的判断，之后执行了一个三元表达式，如果扩容前所需最小容量大于数组最大长度，返回Integer的最大值，否则返回MAX_ARRAY_SIZE,MAX_ARRAY_SIZE的Integer的最大值-8。1234567/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; int的最大值为2的31次方-1，所以说ArrayList的最大容量为2的31次方-1。12345/** * A constant holding the maximum value an &#123;@code int&#125; can * have, 2&lt;sup&gt;31&lt;/sup&gt;-1. */@Native public static final int MAX_VALUE = 0x7fffffff; 回过头来在看我们调用空参构造创建一个ArrayList，并且第一次调用add()方法时发生了什么？扩容，是的，它会将默认的空数组扩容为一个长度为10的数组。 初始化指定集合大小ArrayList(int initialCapacity)《阿里巴巴Java开发手册》里面建议初始化集合时尽量显示的指定集合大小。为什么？读了上面的源码之后，应该可以知道答案了。1.节约内存，实际编码中，很多时候我们都可以知道ArrayList里面会放什么元素以及放多少元素。恰当的设置容器大小可以节约内存。2.避免扩容产生的性能损耗。比如我知道这个集合要放11个元素，那么我可以将集合的大小初始化为11，这样可以避免在添加第11个元素的时候，ArrayList扩容。 ArrayList的扩容底层调用了native方法System.arraycopy()简单点说就是将原来的数组中的元素拷贝到一个新的更大的数组中去。 看下指定初始容量构造的源码:1234567891011121314151617/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125; 逻辑非常简单，如果初始容量&gt;0，则创建一个该大小的数组。如果容量为0，则创建一个空数组。如果容量&lt;0，抛出异常。 初始化传递集合ArrayList(Collection&lt;? extends E&gt; c)12345678910111213141516171819/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 逻辑并不复杂，直接将集合转换为Object数组，赋值给了elementData属性。后面还做了一些保障性操作。 添加元素再探add(E e)方法前面已经看过一点add()方法的源码，知道它首先会确认容量是否够用，如果不够，则进行扩容。注意ArrayList的扩容时机和HashMap有区别，ArrayList只有底层数组已满，不能放下即将存入的对象才会扩容，HashMap的扩容和加载因子有关系，默认情况下，不是容器满了才扩容。123456789101112/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 在确保容量够用之后，直接要添加的元素赋值给elementData数组的下一个空间。 添加到指定位置add(int index, E element)123456789101112131415161718/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; //检查index是否在已有的数组中 if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException("Index:"+index+",Size:"+size); ensureCapacity(size + 1);//确保对象数组elementData有足够的容量，可以将新加入的元素e加进去 System.arraycopy(elementData, index, elementData, index+1, size-index);//将index及其后边的所有的元素整块后移，空出index位置 elementData[index] = element;//插入元素 size++;//已有数组元素个数+1&#125; 使用这个方法，务必注意index的值需要在已经元素的下标之间。 添加所有addAll(Collection&lt;? extends E&gt; c)123456789101112131415161718192021/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray();//将c集合转化为对象数组a int numNew = a.length;//获取a对象数组的容量 ensureCapacity(size + numNew);//确保对象数组elementData有足够的容量，可以将新加入的a对象数组加进去 System.arraycopy(a, 0, elementData, size, numNew);//将对象数组a拷贝到elementData中去 size += numNew;//重新设置elementData中已加入的元素的个数 return numNew != 0;//若加入的是空集合则返回false&#125; ##添加所有到指定位置addAll(int index, Collection&lt;? extends E&gt; c)12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 删除元素删除指定索引元素 E remove(int index)。123456789101112131415161718192021222324252627/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; //索引边界检查 rangeCheck(index); //计数器自增 modCount++; //取得被删除元素 E oldValue = elementData(index); //计算要移动的索引值 int numMoved = size - index - 1; if (numMoved &gt; 0) //如果删除的不是最后一个元素，进行数组拷贝 System.arraycopy(elementData, index+1, elementData, index, numMoved); //将最后一个元素置为null，下次gc回收 elementData[--size] = null; // clear to let GC do its work //返回被删除的值 return oldValue;&#125; 删除指定值的元素 remove(Object o)1234567891011121314151617181920212223242526272829/** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; if (o == null) &#123;//移除对象数组elementData中的第一个null for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123;//移除对象数组elementData中的第一个o for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 12345678910/* * 删除单个位置的元素，是ArrayList的私有方法 */private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0)//删除的不是最后一个元素 System.arraycopy(elementData, index + 1, elementData, index,numMoved);//删除的元素到最后的元素整块前移 elementData[--size] = null; //将最后一个元素设为null，在下次gc的时候就会回收掉了&#125; remove(Object o)需要遍历数组，remove(int index)不需要，只需要判断索引符合范围即可，所以，通常：后者效率更高。 获取元素获取单个元素get(int index)1234567891011/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; rangeCheck(index);//检查索引范围 return (E) elementData[index];//返回元素，并将Object转型为E&#125; 12345678910/** * Checks if the given index is in range. If not, throws an appropriate * runtime exception. This method does *not* check if the index is * negative: It is always used immediately prior to an array access, * which throws an ArrayIndexOutOfBoundsException if index is negative. */private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 注意rangeCheck检查的是size的大小，也就是实际存储元素个数，而不是容器的实际容量。 #遍历元素 iterator()123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; Itr是ArryList的一个私有内部类，实现了Iterator接口。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private class Itr implements Iterator&lt;E&gt; &#123; int cursor = 0;//标记位：标记遍历到哪一个元素 int expectedModCount = modCount;//标记位：用于判断是否在遍历的过程中，是否发生了add、remove操作 //检测对象数组是否还有元素 public boolean hasNext() &#123; return cursor != size();//如果cursor==size，说明已经遍历完了，上一次遍历的是最后一个元素 &#125; //获取元素 public E next() &#123; checkForComodification();//检测在遍历的过程中，是否发生了add、remove操作 try &#123; E next = get(cursor++); return next; &#125; catch (IndexOutOfBoundsException e) &#123;//捕获get(cursor++)方法的IndexOutOfBoundsException checkForComodification(); throw new NoSuchElementException(); &#125; &#125; //检测在遍历的过程中，是否发生了add、remove等操作 final void checkForComodification() &#123; if (modCount != expectedModCount)//发生了add、remove操作,这个我们可以查看add等的源代码，发现会出现modCount++ throw new ConcurrentModificationException(); &#125; @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125;&#125; 需要注意的是这里有一个Java集合的fail-fast事件。你可能已经注意到，我们在调用add()、remove()这些修改集合的方法时，都会修改一个属性modCount。而我们在遍历集合时，首先会保存一份modCount，然后在遍历时，将保存的modCount和成员变量modCount对比，如果不一样，说明被集合已经被修改，抛出ConcurrentModificationException，产生fail-fast事件。 #其他 设置元素set(int index, E element)123456789/** * 更换特定位置index上的元素为element，返回该位置上的旧值 */ public E set(int index, E element) &#123; RangeCheck(index);//检查索引范围 E oldValue = (E) elementData[index];//旧值 elementData[index] = element;//该位置替换为新值 return oldValue;//返回旧值 &#125; 判断元素是否存在1234567891011121314151617181920212223242526272829303132333435363738/** * 判断动态数组是否包含元素o */public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;/** * 返回第一个出现的元素o的索引位置 */public int indexOf(Object o) &#123; if (o == null) &#123;//返回第一个null的索引 for (int i = 0; i &lt; size; i++) if (elementData[i] == null) return i; &#125; else &#123;//返回第一个o的索引 for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;//若不包含，返回-1&#125;/** * 返回最后一个出现的元素o的索引位置 */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size - 1; i &gt;= 0; i--) if (elementData[i] == null) return i; &#125; else &#123; for (int i = size - 1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; #总结1.ArrayList的底层是数组，初始容量是10，当数组满了之后，继续添加元素时，会扩容到原来的1.5倍+1。2.ArrayList保存了一个modCount属性，修改集合的操作都会让其自增。如果在遍历的时候modCount被修改，则会抛出异常，产生fail-fast事件。3.ArrayList内部还维护了一个size属性，它是用来记录数组中的实际元素个数。size,modCount，elementData这些成员变量，都注定了ArrayList线程不安全。4.ArrayList实现了Iterator接口，这表明遍历ArrayList使用普通for循环比使用foreach更快，至于为什么可以参考ArrayList集合实现RandomAccess接口有何作用？为何LinkedList集合却没实现这接口？]]></content>
      <categories>
        <category>java基础</category>
        <category>集合</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 虚拟机内存模型]]></title>
    <url>%2FJVM%2FJava%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2Findex.html</url>
    <content type="text"><![CDATA[JVM内存模型根据《Java虚拟机规范(Java SE 7 版)》的规定，Java虚拟机所管理的内存包括几下几个运行时数据数据: 程序计数器程序计数器是一块较小的内存空间，它可以看做当前线程所执行的字节码的行号指示器,每个线程都有一个程序计数器。如果线程执行的是Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的Native方法，这个计数器的值则为空。 Java虚拟机栈线程私有，生命周期和线程相同。每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型(指向了一条字节码指令的地址)。 Java虚拟机规范，规定了这个区域的两种异常状况:如果线程请求的栈深度大于虚拟机锁允许的深度，将抛出StackOverflowError；如果虚拟机可以动态扩展(大部分虚拟机都支持),在扩展时无法申请到足够的内存，将抛出OutOfMemoryError异常。 本地方法栈线程私有，作用和虚拟机栈非常相似，只不过虚拟机栈为Java方法服务，本地方法栈为native方法服务。 Java堆Java虚拟机所管理的最大的一块内存，几乎所有的对象实例都在这里分配内存。被所有线程共享。堆内存也是java dc发生的主要区域，因此也被称为GC堆。内内存继续细分的话，可以分为Eden区、From Survivor区、To Survivor区等。堆内存可以是不连续的内存空间，只要逻辑上是连续的即可。可以通过-Xmx和-Xms控制大小。 方法区线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编辑器编译后的代码等数据。相对而言，GC很少发生在该区域。 方法区有一个运行时常量池(Runtime Constant Pool)，Class文件除了有类的版本、字段、方法接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring@Value注解总是null问题记录]]></title>
    <url>%2Fspring%2FSpring%40Value%E6%B3%A8%E8%A7%A3%E6%80%BB%E6%98%AFnull%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2Findex.html</url>
    <content type="text"><![CDATA[问题描述在使用@value注解之后，字段总是为空。后来发现是因为字段使用了static修饰。123456789@Componentpublic class TestValue &#123; @Value(&quot;$&#123;appEnv&#125;&quot;) private static String appenv; //null public String test() &#123; return appenv; &#125;&#125; 原因spring的依赖注入不支持为static变量注入。spring 依赖注入的底层原理还是利用反射来创建对象。而static变量，在jvm加载类的时候便已经创建，存在于方法区，被所有实例共享，属于类的属性而不是对象的属性。spring是基于对象层面的依赖注入。 解决1.使用set方法注入，非静态setter 方法注入静态变量。如：1234567891011121314import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class GlobalValue &#123; public static String DATABASE; @Value(&quot;$&#123;mongodb.db&#125;&quot;) public void setDatabase(String db) &#123; DATABASE = db; &#125; &#125; 2.@PostConstruct方式实现1234567891011121314151617import org.mongodb.morphia.AdvancedDatastore; import org.springframework.beans.factory.annotation.Autowired; @Component public class MongoFileOperationUtil &#123; @Autowired private static AdvancedDatastore dsForRW; private static MongoFileOperationUtil mongoFileOperationUtil; @PostConstruct public void init() &#123; mongoFileOperationUtil = this; mongoFileOperationUtil.dsForRW = this.dsForRW; &#125; &#125; @PostConstruct，会在构造方法之后执行。其给static变量赋值的原理和set方法差不多，都是调用非静态方法给静态变量赋值]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[netty系列之--1.netty框架基本介绍]]></title>
    <url>%2Fnetty%2Fnetty1%2Findex.html</url>
    <content type="text"><![CDATA[netty是什么？]]></content>
      <categories>
        <category>netty</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性 使用Optional避免NPE]]></title>
    <url>%2Fjava8%2Foptional%2Findex.html</url>
    <content type="text"><![CDATA[前言相信每一个Java程序员都碰到过NPE异常，每个避免NPE，往往会在代码中写很多if判断，形成代码污染。为了解决这个问题，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。 Optional类介绍Optional类存在于java.util包中，它是一个用来存放null值或者非null值的容器。如果容器内有值，isPresent()方法返回true,使用get()方法可以取到这个值.除此之外，还提供了基于对值存在与否的判断的其他方法，比如：orElse()(如果值不存在，则返回默认值)ifPresent()(如果值存在，则执行代码块)需要注意的是，这是一个“基于值(value-based)”的类，使用对身份敏感的操作，比如(比较符号’==’,一致性哈希或同步)都可能出现意想不到的结果，这类操作应该避免。什么是value-based class? Optional类的方法注:第一排:m:表示方法,左下角有个白色标志的表示static方法 f:表示变量第二排:上锁表示为private方法,解锁表示public第三排:方法或变量名称第四排:方法返回值 我们一个个看 empty() 创建一个空的Optional对象public static Optional empty()返回一个Optional对象，其存储的值是null1234Optional&lt;Object&gt; emptyOptional = Optional.empty();System.out.println(emptyOptional);result:Optional.empty 注意判断Optional值是否为Null,不要使用null == Optional.empty(),而应该使用isPresent() of() 创建一个不为空的Optional对象，如果值为null，抛出NPE1234Optional&lt;Object&gt; optional = Optional.of(1);System.out.println(optional);result:Optional[1] ofNullable()创建一个可为空的Optional对象12345678Optional&lt;Object&gt; emptyOptional = Optional.ofNullable(null);Optional&lt;Long&gt; longOptional = Optional.ofNullable(2L);System.out.println(emptyOptional);System.out.println(longOptional);result: Optional.empty Optional[2] isPresent() 判断值是否存在public boolean isPresent()12345678910Optional&lt;Object&gt; optional = Optional.of(1);Optional&lt;Object&gt; emptyOptional = Optional.ofNullable(null);boolean isPresent = optional.isPresent();boolean emptyOptionalPresent = emptyOptional.isPresent();System.out.println(isPresent);System.out.println(emptyOptionalPresent);result: true false ifPresent() 注意不是isPresent()当值存在的时候，执行传入的代码1234Optional&lt;Object&gt; optional = Optional.of(1);optional.ifPresent(e-&gt; System.out.println((Integer)e+1));result:2 orElse() 如果存在返回原来的值，不存在，则返回指定的值public T orElse(T other) 12345678910Optional&lt;Object&gt; optional = Optional.of(1);Optional&lt;Object&gt; emptyOptional = Optional.empty();Object orElse = optional.orElse(2);Object orElse2 = emptyOptional.orElse(2);System.out.println(orElse);System.out.println(orElse2);result: 1 2 稍微复杂点的例子:1234567891011121314151617181920212223242526public class User &#123; private String name; private Integer age; public User(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public Integer getAge() &#123; return age; &#125;&#125;List&lt;User&gt; userList = Arrays.asList(new User(&quot;李四&quot;, 20), new User(&quot;张三&quot;, 18), new User(&quot;王五&quot;, 25));User user = userList.stream().filter(e -&gt; e.getAge() &gt; 25).findFirst().orElse(new User(&quot;王老五&quot;, 30));System.out.println(user.getName());result:王老五 orElseGet() 如果存在，返回原来的值，如果不存在，返回返回函数式接口的结果public T orElseGet(Supplier&lt;? extends T&gt; other)和orElse不同的是，这个可以传入一个函数表达式123456Optional&lt;Object&gt; emptyOptional = Optional.empty();String name = &quot;王老五&quot;;Object orElseGet = emptyOptional.orElseGet(name::length);System.out.println(orElseGet);result:3 orElseThrow 如果存在，返回原来的值，如果不存在，抛出一个指定的异常public T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X 123456Optional&lt;Object&gt; emptyOptional = Optional.empty();Object orElseThrow = emptyOptional.orElseThrow(()-&gt;new RuntimeException(&quot;程序异常&quot;));result:Exception in thread &quot;main&quot; java.lang.RuntimeException: 程序异常... filter() 按要求返回过滤后的元素，没有返回一个空的Optional对象public Optional filter(Predicate&lt;? super T&gt; predicate)1234567891011Optional&lt;Object&gt; optional = Optional.of(1);Optional&lt;Object&gt; emptyOptional = Optional.empty();Optional&lt;Object&gt; optionalO = optional.filter(e -&gt; e.equals(1));Optional&lt;Object&gt; optionalO1 = emptyOptional.filter(e -&gt; e.equals(1));System.out.println(optionalO);System.out.println(optionalO1);result: Optional[1] Optional.empty map() 对Optional中保存的值进行函数运算，并返回新的Optional,里面保存的值可以是任何类型12345User user = new User(&quot;李四&quot;, 20);Optional&lt;Integer&gt; optionalInteger = Optional.of(new User(&quot;李四&quot;, 20)).map(User::getAge);System.out.println(optionalInteger);result:Optional[20] flatMap() 和map(),区别在于，保存的只只能和调用方一样123456789101112User user = new User(&quot;李四&quot;, 20);Optional&lt;User&gt; user1 = userOptional.flatMap(e -&gt; &#123; if (e.getAge() &gt; 19) &#123; return Optional.of(new User(&quot;张三&quot;, 21)); &#125; else &#123; return Optional.of(new User(&quot;王五&quot;, 18)); &#125;&#125;);System.out.println(user1.get().getName());result:张三]]></content>
      <categories>
        <category>java8</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo+travis+阿里云oss持续集成个人博客]]></title>
    <url>%2Fother%2Fhexo%20travis%20%E9%98%BF%E9%87%8C%E4%BA%91oss%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2Findex.html</url>
    <content type="text"><![CDATA[这两天抽空用hexo搭建了一个静态博客，并且使用travis+github pages做持续集成。后来对github pages的响应速度不是很满意，便将博客换成了hexo+travis+oss。 实现的效果是只需要提交代码，便自动将博客更新到github pages 和oss上面。 使用hexo+travis+github pages 完成持续部署的过程不在赘述，网上有很多教程，不过质量参差不齐，这里推荐一篇：使用Travis CI自动部署Hexo博客 按照这篇文章操作，应该就可以实现hexo+travis+github pages持续集成。我在这个基础上，增加了对oss的持续集成。 有关oss如何部署静态页面，参考如何将 hexo 生成的博客部署至阿里云 OSS 并全站启用 CDN 加速访问 值得一提的是，如果需要将oss绑定到域名，需要备案。 接下来需要做的是在push代码的时候，将构建出来的静态文件上传到oss中。这里我使用的是阿里云oss提供的工具类：命令行工具ossutil 首先将ossutil下载，放到hexo源码根目录: 在上传只github pages的基础上，增加以下代码:1234567891011# 进入根目录cd ../# 开启权限chmod 755 ossutil64# 配置endpoint，id 秘钥./ossutil64 config -e &lt;your oss endpoint&gt; -i &lt;your AccessKey ID&gt; -k &lt;your Access Key Secret&gt;# 先删除所有文件，防止出现文件改名后不能覆盖的问题./ossutil64 rm oss://keji-blog-hexo -r -f# 上传public文件至oss./ossutil64 cp public oss://keji-blog-hexo/ -r -f --loglevel=debug 这样，便可以了。]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BigDecimal使用案例]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%2FBigDecimal%2FBigDecimal%2Findex.html</url>
    <content type="text"><![CDATA[创建BigDecimal对象创建BigDecimal对象常用的方式有2种：12BigDecimal a = new Bigdecimal(1);BigDecimal a1 = BigDecimal.valueOf(1); 不推荐使用new 关键字创建Bigdecimal对象。原因是当new 的值是一个小数的时候，其真实的值并不是我们想要的值1234BigDecimal b = new BigDecimal(1.1);BigDecimal b1 = BigDecimal.valueOf(1.1);System.out.println("new的值b: "+b);System.out.println("valueOf()的值b1: "+b1); 输出:121.100000000000000088817841970012523233890533447265625valueOf()的值b1: 1.1 这在比较大小的时候，很可能出现意想不到的结果。 例如: 123BigDecimal a = new BigDecimal(1.1);String b = "1.1";System.out.println(a.toString().equals(b)); //fasle 如果不注意，很可能产生bug。 加法加法的方法有两种，方法签名如下:12public BigDecimal add(BigDecimal augend)public BigDecimal add(BigDecimal augend, MathContext mc) MathContext 用于指定精度和舍入模式，具体查看官方javadoc demo:12345678910111213BigDecimal a = BigDecimal.valueOf(1);BigDecimal b = BigDecimal.valueOf(1.5);BigDecimal c = BigDecimal.valueOf(1.4);BigDecimal addResult = a.add(b);BigDecimal addResult1 = a.add(b,new MathContext(2));BigDecimal addResult2 = a.add(b,new MathContext(1));BigDecimal addResult3 = a.add(c,new MathContext(1));System.out.println("addResult: "+addResult);System.out.println("addResult1: "+addResult1);System.out.println("addResult2: "+addResult2);System.out.println("addResult3: "+addResult3); result:1234addResult: 2.5addResult1: 2.5addResult2: 3addResult3: 2 mc 设置保留几位小数，舍入按四舍五入 减法方法签名如下：12public BigDecimal subtract(BigDecimal subtrahend)public BigDecimal subtract(BigDecimal subtrahend, MathContext mc) demo：12345678910111213BigDecimal a = BigDecimal.valueOf(1);BigDecimal b = BigDecimal.valueOf(1.5);BigDecimal c = BigDecimal.valueOf(1.4);BigDecimal subtract = a.subtract(b);BigDecimal subtract1 = a.subtract(b,new MathContext(2));BigDecimal subtract2 = a.subtract(b,new MathContext(1));BigDecimal subtract3 = a.subtract(c,new MathContext(1));System.out.println("subtract: "+subtract);System.out.println("subtract1: "+subtract1);System.out.println("subtract2: "+subtract2);System.out.println("subtract3: "+subtract3); result：1234subtract: -0.5subtract1: -0.5subtract2: -0.5subtract3: -0.4 乘法：方法签名:12public BigDecimal multiply(BigDecimal multiplicand)public BigDecimal multiply(BigDecimal multiplicand, MathContext mc) demo:12345678910111213BigDecimal a = BigDecimal.valueOf(1);BigDecimal b = BigDecimal.valueOf(1.5);BigDecimal c = BigDecimal.valueOf(1.4);BigDecimal multiply = a.multiply(b);BigDecimal multiply1 = a.multiply(b,new MathContext(2));BigDecimal multiply2 = a.multiply(b,new MathContext(1));BigDecimal multiply3 = a.multiply(c,new MathContext(1));System.out.println("multiply: "+multiply);System.out.println("multiply1: "+multiply1);System.out.println("multiply2: "+multiply2);System.out.println("multiply3: "+multiply3); result:1234multiply: 1.5multiply1: 1.5multiply2: 2multiply3: 1 除法:123456public BigDecimal divide(BigDecimal divisor)public BigDecimal divide(BigDecimal divisor, MathContext mc)public BigDecimal divide(BigDecimal divisor, int roundingMode)public BigDecimal divide(BigDecimal divisor, RoundingMode roundingMode)public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 其中 public BigDecimal divide(BigDecimal divisor) 不推荐使用。idea警告如下:123456Inspection info: Reports calls to divide() or setScale() without a rounding mode argument. Such calls can lead to an ArithmeticException when the exact value cannot be represented in the result (e.g. because it has a non-terminating decimal expansion). Specifying a rounding mode prevents the ArithmeticException.翻译:检查信息:报告调用divide()或setScale()，而不带舍入模式参数。当结果中不能表示精确值时，这种调用可能导致算术异常(例如，因为它具有无限的十进制展开)。指定舍入模式可以防止算术异常。简单点说就是除不尽的时候会报错 所以用除法的时候，我们需要指定其舍入模式。推荐使用:12public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 指定舍入模式，和保留几位小数 demo:12BigDecimal divide = a.divide(b, 2, BigDecimal.ROUND_HALF_UP);System.out.println("divide: "+divide);]]></content>
      <categories>
        <category>java基础</category>
        <category>BigDecimal</category>
      </categories>
  </entry>
</search>
