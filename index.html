<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="有志，则不甘为下流；有识，则知学问无尽；有恒，则断无不成之事">
<meta property="og:type" content="website">
<meta property="og:title" content="克己的博客">
<meta property="og:url" content="/index.html">
<meta property="og:site_name" content="克己的博客">
<meta property="og:description" content="有志，则不甘为下流；有识，则知学问无尽；有恒，则断无不成之事">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="克己的博客">
<meta name="twitter:description" content="有志，则不甘为下流；有识，则知学问无尽；有恒，则断无不成之事">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '克己'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="/">





  <title>克己的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b6a5ba0ede6adca5bc5c4042599338ca";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">克己的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/Java集合/CurrentHashMap源码解析/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Java集合/CurrentHashMap源码解析/index.html" itemprop="url">CurrentHashMap源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T17:21:37+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java集合/index.html" itemprop="url" rel="index">
                    <span itemprop="name">Java集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/Java集合/CurrentHashMap源码解析/index.html" class="leancloud_visitors" data-flag-title="CurrentHashMap源码解析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="$appres/images/night.jpg" alt="Nulla euismod, vitae aliquet orci eleifend."></p>
<h1 id="Lorem-ipsum"><a href="#Lorem-ipsum" class="headerlink" title="Lorem ipsum"></a>Lorem ipsum</h1><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus eu tempor dolor. Nulla hendrerit convallis purus et elementum. Suspendisse non magna vel justo tincidunt finibus. Nullam dui erat, malesuada eget viverra non, finibus a nisl.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/uncategorized/Java数据结构 Tree/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/Java数据结构 Tree/index.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T17:21:37+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/uncategorized/Java数据结构 Tree/index.html" class="leancloud_visitors" data-flag-title>
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java数据结构-树（Tree）"><a href="#Java数据结构-树（Tree）" class="headerlink" title="Java数据结构:树（Tree）"></a>Java数据结构:树（Tree）</h1><h1 id="计算机科学中的树"><a href="#计算机科学中的树" class="headerlink" title="计算机科学中的树"></a>计算机科学中的树</h1><p>在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<ul>
<li>每个节点都只有有限个子节点或无子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
<li>树里面没有环路(cycle)</li>
</ul>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/tree.png" alt></p>
<h1 id="为什么需要树"><a href="#为什么需要树" class="headerlink" title="为什么需要树"></a>为什么需要树</h1><p>为什么要用到树呢？因为它通常结合了另外两种数据结构的优点：<br>一种是有序数组，另一种是链表。在树中查找数据项的速度和在有序数组中查找一样快， 并且插入数据项和删除数据项的速度也和链表一样。下面，我们先来稍微思考一下这些话题，然后<br>再深入地研究树的细节。</p>
<h2 id="在有序数组中插入数据项太慢"><a href="#在有序数组中插入数据项太慢" class="headerlink" title="在有序数组中插入数据项太慢"></a>在有序数组中插入数据项太慢</h2><p>假设数组中的所有数据项都有序的排列—这就是有序数组，用二分查找法可以在有序数组中快速地查找特定的值。它的过程是先査看数组的正中间的数据项，如果那个数据项值比要找的大，就缩小査找范围，在数组的后半段中找；如果小， 就在前半段找。反复这个过程，查找数据所需的时间是O(logN)。同时也可以迅速地遍历有序数组， 按顺序访问每个数据项。</p>
<p>然而，想在有序数组中插入一个新数据项，就必须首先査找新数据项插入的位置，然后把所有<br>比新数据项大的数据项向后移动一位，来给新数据项腾出空间。这样多次的移动很费时，’平均来讲<br>要移动数组中一半的数据项(N/2次移动)。删除数据项也需要多次的移动，所以也很慢。<br>显而易见，如果要做很多的插入和删除操作，就不该选用有序数组。</p>
<h2 id="在链表中查找太慢"><a href="#在链表中查找太慢" class="headerlink" title="在链表中查找太慢"></a>在链表中查找太慢</h2><p>链表的插入和删除操作都很快。它们只需要改变一些引用的值就行了。这些操作的时间复杂度是0(1)(是大O表示法中最小的时间复杂度)。</p>
<p>但是在链表中查找数据项可不那么容易。查找必须从头开始，依次访问链表中的每一个数据项，直到找到该数据项为止。因此，平均需要访问N/2个数据项，把每个数据项的值和要找的数据项做比较。这个过程很慢，费时O(N)(注意，对排序来说比较快的，对数据结构操作来说是比较慢的。)。</p>
<p>不难想到可以通过有序的链表来加快查找速度，链表中的数据项是有序的，但这样做是没有用的。即使是有序的链表还是必须从头开始依次访问数据项，因为链表中不能直接访问某个数据项，必须通过数据项间的链式引用才可以。（当然有序链表访问节点还是比无序链表快多了，但查找任意的数据项时它也无能为力了 o ）</p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><ol>
<li>节点的度：一个节点含有的子树的个数称为该节点的度；</li>
<li>树的度：一棵树中，最大的节点度称为树的度；</li>
<li>叶节点或终端节点：度为零的节点；</li>
<li>非终端节点或分支节点：度不为零的节点；</li>
<li>父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</li>
<li>高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；</li>
<li>堂兄弟节点：父节点在同一层的节点互为堂兄弟；</li>
<li>节点的祖先：从根到该节点所经分支上的所有节点；</li>
<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li>森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
</ol>
<h1 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h1><p>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；<br>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；<br>　二叉树：每个节点最多含有两个子树的树称为二叉树；<br>　　完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；<br>　　　满二叉树：所有叶节点都在最底层的完全二叉树；<br>　　平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；<br>　　排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树；<br>　　霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；<br>　　B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。</p>
<h1 id="树的抽象（ADT）"><a href="#树的抽象（ADT）" class="headerlink" title="树的抽象（ADT）"></a>树的抽象（ADT）</h1><p>树作为一种抽象的数据类型，至少要支持以下的基本方法<br>方法名 | 描述 |<br>-|-|<br>getElement() | ： 返回存放于当前节点处的对象|<br>setElement(e) | 将对象 e 存入当前节点，并返回其中此前所存的内容|<br>getParent() | 返回当前节点的父节点|<br>getParent() | 返回当前节点的父节点|<br>getFirstChild()|返回当前节点的长子   |<br>getNextSibling()  | 返回当前节点的最大弟弟  |  </p>
<h1 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h1><h2 id="使用数组实现"><a href="#使用数组实现" class="headerlink" title="使用数组实现"></a>使用数组实现</h2><p>树可以使用数组实现，节点在数组中的位置对应于它在树中的位置。下标为0的节点是根，下标为1的节点是根的左子节点，依次类推，按从左到右的顺序存储树的每一层。<br><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/arrTree.png" alt></p>
<p>树中的每个位置，无论是否存在节点，都对应数组中的一个位置。把节点插入树的一个位置， 意味着要在数组的相应位置插入一个数据项。树中没有节点的位置在数组中的对应位置用0或null来表示。</p>
<p>基于这种思想，找节点的子节点和父节点可以利用简单的算术计算它们在数组中的索引值。设节点索引值为index,则节点的左子节点是：2<em>index + 1 ,它的右子节点是2</em>index + 2,它的父节点是（index-1） / 2</p>
<p>大多数情况下用数组表示树不是很有效率。不满的节点和删除掉的节点在数组中留下了洞，浪费存储空间。更坏的是，删除节点时需要移动子树的话，子树中的每个节点都要移到数组中新的位置去，这在比较大的树中是很费时的。</p>
<p>不过，如果不允许删除操作，数组表示可能会很有用，特别是因为某种原因要动态地为每个节点分配空间非常耗时。数组表示法在其他一些特殊的情况下也很有用。</p>
<h2 id="使用链表实现"><a href="#使用链表实现" class="headerlink" title="使用链表实现"></a>使用链表实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> keji</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : Tree.java, v 0.1 2019-07-18 9:46 keji Exp $$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前节点中存放的对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getElem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象obj存入当前节点，并返回此前的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">setElem</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前节点的父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeLinkedList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TreeLinkedList <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前节点的长子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeLinkedList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TreeLinkedList <span class="title">getFirstChild</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前节点的最大弟弟</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeLinkedList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TreeLinkedList <span class="title">getNextSibling</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前节点后代元素的数目，即以当前节点为根的子树的规模</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前节点的高度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前节点的深度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> keji</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> : TreeLinkedList.java, v 0.1 2019-07-18 9:46 keji Exp $$</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkedList</span> <span class="keyword">implements</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 树根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object element;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父节点、长子及最大的弟弟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TreeLinkedList parent, firstChild, nextSibling;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * （单节点树）构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object      树根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent      父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstChild  长子</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nextSibling 最大的弟弟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeLinkedList</span><span class="params">(Object object, TreeLinkedList parent, TreeLinkedList firstChild, TreeLinkedList nextSibling)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = object;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.firstChild = firstChild;</span><br><span class="line">        <span class="keyword">this</span>.nextSibling = nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getElem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">setElem</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Object bak = element;</span><br><span class="line">        element = obj;</span><br><span class="line">        <span class="keyword">return</span> bak;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getFirstChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getNextSibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前节点也是自己的后代</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从长子开始</span></span><br><span class="line">        TreeLinkedList subtree = firstChild;</span><br><span class="line">        <span class="comment">//依次</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != subtree) &#123;</span><br><span class="line">            <span class="comment">//累加</span></span><br><span class="line">            size += subtree.getSize();</span><br><span class="line">            <span class="comment">//所有孩子的后代数目</span></span><br><span class="line">            subtree = subtree.getNextSibling();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到当前节点的后代总数</span></span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从长子开始</span></span><br><span class="line">        TreeLinkedList subtree = firstChild;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != subtree) &#123;</span><br><span class="line">            <span class="comment">//在所有孩子中取最大高度</span></span><br><span class="line">            height = Math.max(height, subtree.getHeight());</span><br><span class="line">            subtree = subtree.getNextSibling();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//即可得到当前节点的高度</span></span><br><span class="line">        <span class="keyword">return</span> height + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从父亲开始</span></span><br><span class="line">        TreeLinkedList p = parent;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != p) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="comment">//访问各个真祖先</span></span><br><span class="line">            p = p.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//真祖先的数目，即为当前节点的深度</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><p>所谓树的遍历（Traversal），就是按照某种次序访问树中的节点，且每个节点恰好访问一次。</p>
<p>也就是说，按照被访问的次序，可以得到由树中所有节点排成的一个序列。</p>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>对任一（子）树的前序遍历，将首先访问其根节点，然后再递归地对其下的各棵子树进行前序遍历。对于同一根节点下的各棵子树，遍历的次序通常是任意的；但若换成有序树，则可以按照兄弟间相应的次序对它们实施遍历。由前序遍历生成的节点序列，称作前序遍历序列。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/tree_pre_iter.png" alt></p>
<h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p>对称地，对任一（子）树的后序遍历将首先递归地对根节点下的各棵子树进行后序遍历，最后才访问根节点。由后序遍历生成的节点序列，称作后序遍历序列。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/tree_last_iter.png" alt></p>
<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>除了上述两种最常见的遍历算法，还有其它一些遍历算法，层次遍历（Traversal by level ）算法就是其中的一种。在这种遍历中，各节点被访问的次序取决于它们各自的深度，其策略可以总结为“深度小的节点优先访问”。对于同一深度的节点，访问的次序可以是随机的，通常取决于它们的存储次序，即首先访问由firstChild指定的长子，然后根据nextSibling确定后续节点的次序。当然，若是有序树，则同深度节点的访问次序将与有序树确定的次序一致。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/tree_floor_iter.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/uncategorized/Java数据结构：二叉树与二叉搜索树/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/Java数据结构：二叉树与二叉搜索树/index.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T17:21:37+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/uncategorized/Java数据结构：二叉树与二叉搜索树/index.html" class="leancloud_visitors" data-flag-title>
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java数据结构：二叉树与二叉搜索树"><a href="#Java数据结构：二叉树与二叉搜索树" class="headerlink" title="Java数据结构：二叉树与二叉搜索树"></a>Java数据结构：二叉树与二叉搜索树</h1><p>上一篇介绍了树这种数据结构，并用Java代码使用链表实现了树。<a href="https://zhuanlan.zhihu.com/p/74141967" target="_blank" rel="noopener"></a>,接下来介绍树的其中一种特例，二叉树。</p>
<p>在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。</p>
<p>二叉树的第 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/i.svg" alt>层至多拥有 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/2i-1.svg" alt>个节点；深度为 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/k.svg" alt>的二叉树至多总共有<img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/2k-1.svg" alt>个节点（定义根节点所在深度 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/k0%3D0.svg" alt>），而总计拥有节点数匹配的，称为“满二叉树”；深度为 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/k.svg" alt>有<img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/n.svg" alt>个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度<img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/k.svg" alt>的满二叉树，序号为1到<img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/n.svg" alt>的节点一对一对应时，称为完全二叉树。对任何一棵非空的二叉树<img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/t.svg" alt>，如果其叶片（终端节点）数为 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/n0.svg" alt="title">，分支度为2的节点数为 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/n2.svg" alt="title">，则 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/n0%3Dn2.svg" alt="title">。</p>
<p>与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。</p>
<p>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。</p>
<h1 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h1><h2 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h2><p>首先，需要有一个节点对象的类。这些对象包含数据，数据代表要存储的内容（例如，在员工<br>数据库中的员工记录），而且还有指向节点的两个子节点的引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 角标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer index;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node leftChild;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node rightChild;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  　&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 角标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer index, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.leftChild = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.rightChild = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有些实现也把节点的父节点的引用包括在Node类中。这样做会使一些操作简化，但使一些别的操作复杂，所以这里不使用它。</p>
<p>这个类中还有一个叫displayNode()的方法，用它来显示节点数据，不过在这里没有写出它的代码。</p>
<h2 id="Tree类"><a href="#Tree类" class="headerlink" title="Tree类"></a>Tree类</h2><p>还需要有一个表示树本身的类，由这个类实例化的对象含有所有的节点，这个类是Tree类。它只有一个数据字段：一个表示根的Node变量。它不需要包含其他节点的数据字段，因为其他节点都可以从根开始访问到。</p>
<p>Tree类有很多方法。它们用来查询、插入和删除节点；进行各种不同的遍历；显示树。下面是这个类的骨架:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> id, T data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>作为树的一种特例，二叉树自然继承了一般树结构的前序、后序以及层次等遍历方法。这三个遍历算法的实现与普通树大同小异，这里不再赘述。</p>
<p>需要特别指出的是，对二叉树还可以定义一个新的遍历方法⎯⎯中序遍历（Inorder traversal）。顾名思义，在访问每个节点之前，首先遍历其左子树；待该节点被访问过后，才遍历其右子树。类似地，由中序遍历确定的节点序列，称作中序遍历序列。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/Tree_Inorder_iter.png" alt></p>
<h2 id="二叉搜索树（Binary-Search-Tree）"><a href="#二叉搜索树（Binary-Search-Tree）" class="headerlink" title="二叉搜索树（Binary Search Tree）"></a>二叉搜索树（Binary Search Tree）</h2><p>二叉搜索树（英语：Binary Search Tree），也称为二叉查找树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ol>
<p>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/lognsvg.svg" alt>。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。</p>
<p>二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。</p>
<p>每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/lognsvg.svg" alt>，最坏 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/on.svg" alt>（数列有序，树退化成线性表）。</p>
<p>虽然二叉查找树的最坏效率是 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/on.svg" alt>，但它支持动态查询，且有很多改进版的二叉查找树可以使树高为 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/lognsvg.svg" alt>，从而将最坏效率降至 <img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/lognsvg.svg" alt>，如AVL树、红黑树等。</p>
<h3 id="在二叉搜索树插入节点的算法"><a href="#在二叉搜索树插入节点的算法" class="headerlink" title="在二叉搜索树插入节点的算法"></a>在二叉搜索树插入节点的算法</h3><p>向一个二叉搜索树b中插入一个节点s的算法，过程为：</p>
<ol>
<li>若b是空树，则将s所指节点作为根节点插入，否则：</li>
<li>若s-&gt;data等于b的根节点的数据域之值，则返回，否则：</li>
<li>若s-&gt;data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：</li>
<li>把s所指节点插入到右子树中。（新插入节点总是叶子节点）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> id, T data)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">        newNode.setIndex(id);</span><br><span class="line">        newNode.setData(data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">            root = newNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从根节点开始查找</span></span><br><span class="line">            Node&lt;T&gt; current = root;</span><br><span class="line">            <span class="comment">//声明父节点的引用</span></span><br><span class="line">            Node&lt;T&gt; parent;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//父节点的引用指向当前节点</span></span><br><span class="line">                parent = current;</span><br><span class="line">                <span class="comment">//如果角标小于当前节点,插入到左节点</span></span><br><span class="line">                <span class="keyword">if</span> (id &lt; current.getIndex()) &#123;</span><br><span class="line">                    current = current.getLeftChild();</span><br><span class="line">                    <span class="comment">//节点为空才进行赋值，否则继续查找</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == current) &#123;</span><br><span class="line">                        parent.setLeftChild(newNode);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则插入到右节点</span></span><br><span class="line">                    current = current.getRightChild();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == current) &#123;</span><br><span class="line">                        parent.setRightChild(newNode);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树的查找算法"><a href="#二叉搜索树的查找算法" class="headerlink" title="二叉搜索树的查找算法"></a>二叉搜索树的查找算法</h3><p>在二叉搜索树b中查找x的过程为：</p>
<ol>
<li>若b是空树，则搜索失败，否则：</li>
<li>若x等于b的根节点的数据域之值，则查找成功；否则：</li>
<li>若x小于b的根节点的数据域之值，则搜索左子树；否则：</li>
<li>查找右子树。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　Node&lt;T&gt; current = root;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//如果不是当前节点</span></span><br><span class="line">　　<span class="keyword">while</span> (current.getIndex() != key) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (key &lt; current.getIndex()) &#123;</span><br><span class="line">　　　　　　current = current.getLeftChild();</span><br><span class="line">　　　　&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　current = current.getRightChild();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　</span><br><span class="line">　　　　<span class="comment">//如果左右节点均为null，查找失败</span></span><br><span class="line">　　　　<span class="keyword">if</span> (<span class="keyword">null</span> == current) &#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在二叉查找树删除结点的算法"><a href="#在二叉查找树删除结点的算法" class="headerlink" title="在二叉查找树删除结点的算法"></a>在二叉查找树删除结点的算法</h3><p>删除节点是二叉搜索树常用的一般操作中最复杂的。但是，删除节点在很多树的应用中又非常重要，所以要详细研究并总结特点。</p>
<p>删除节点要从查找要删的节点开始入手，方法与前面介绍的find()和insert()相同。找到节点后,这个要删除的节点要分三种情况讨论：</p>
<ol>
<li>该节点是叶节点(没有子节点)。</li>
<li>该节点有一个子节点。</li>
<li>该节点有两个子节点。</li>
</ol>
<h4 id="情况一：删除没有子节点的节点"><a href="#情况一：删除没有子节点的节点" class="headerlink" title="情况一：删除没有子节点的节点"></a>情况一：删除没有子节点的节点</h4><p>要删除叶节点，只需要改变该节点的父节点的对应子字段的值，由指向该节点、改为null就可以了。要删除的节点仍然存在，但它已经不是树的一部分了。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/tree_del.png" alt></p>
<p>因为Java语言有垃圾自动收集的机制，所以不需要非得把节点本身给删掉。</p>
<h4 id="情况二-删除只有一个子节点的节点"><a href="#情况二-删除只有一个子节点的节点" class="headerlink" title="情况二 删除只有一个子节点的节点"></a>情况二 删除只有一个子节点的节点</h4><p>第二种情况也不是很难。这个节点只有两个连接：连向父节点的和连向它惟一的子节点的。</p>
<p>需要从这个序列中“剪断”这个节点，把它的子节点直接连到它的父节点上。这个过程要求改变父节点适当的引用(左子节点还是右子节点)，指向要删除节点的子节点。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/tree_del_one_child.png" alt></p>
<h4 id="情况三-删除有两个子节点的节点"><a href="#情况三-删除有两个子节点的节点" class="headerlink" title="情况三 删除有两个子节点的节点"></a>情况三 删除有两个子节点的节点</h4><p>下面有趣的情况出现了。如果要删除的节点有两个子节点，就不能只是用它的一个子节点代替它。为什么不能这样呢？看图：</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/tree_del_two_child.png" alt></p>
<p>假设要删除节点25,并且用它的根是35的右子树取代它。那么35的左子节点应该是谁呢？是要删除节点25的左子节点15,还是35原来的左子节点30？然而在这两种情况中30都会被放得不对，但又不能删掉它。</p>
<p>对每一个节点来说，比该节点的关键字值次高的节点是它的中序后继，可以简称为该节点的后继。在上图中，节点30就是节点25的后继。</p>
<p>这里有一个窍门：删除有两个子节点的节点，用它的中序后继来代替该节点。如下图：<br><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/tree_del_replace.png" alt></p>
<p>这里还有更麻烦的情况是它的后继自己也有子节点，后面会讨论这种可能性。</p>
<p><strong>找后继节点</strong></p>
<p>怎么找节点的后继呢？算法如下:</p>
<p>首先，找到初始节点的右子节点A，它的关键字值一定比初始节点大。然后转到A的左子节点那里（如果有的话），然后到这个左子节点的左子节点，以此类推，顺着左子节点的路径一直向下找。这个路径上的最后一个左子节点就是初始节点的后继。</p>
<p>如果初始节点的右子节点没有左子节点，那么这个右子节点本身就是后继。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/findSuccessor.png" alt></p>
<p>以下是找后继节点的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">getSuccessor</span><span class="params">(Node&lt;T&gt; delNode)</span> </span>&#123;</span><br><span class="line">　　Node&lt;T&gt; successorParent = delNode;</span><br><span class="line">　　Node&lt;T&gt; successor = delNode;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//go to rightChild</span></span><br><span class="line">　　Node&lt;T&gt; current = delNode.getRightChild();</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">　　　　<span class="comment">//一直往下找左节点</span></span><br><span class="line">　　　　successorParent = successor;</span><br><span class="line">　　　　successor = current;</span><br><span class="line">　　　　current = current.getLeftChild();</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//跳出循环，此时successor为最后的一个左节点，也就是被删除节点的后继节点</span></span><br><span class="line">　　</span><br><span class="line">　　<span class="comment">//这里的判断先忽视，在后面会讲</span></span><br><span class="line">　　<span class="keyword">if</span> (successor != delNode.getRightChild()) &#123;</span><br><span class="line">　　　　successorParent.setLeftChild(successor.getRightChild());</span><br><span class="line">　　　　successor.setRightChild(delNode.getRightChild());</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法首先找到delNode的右子节点，然后，在while循环中，顺着这个右子节点所有左子节点的路径向下查找。当while循环中止时，successor就存有delNode的后继。</p>
<p>找到后继后，还需要访问它的父节点，所以在while循环中还需要保留当前节点的父节点。</p>
<p>正如看到的那样，后继节点可能与current有两种位置关系，current就是要删除的节点。后继可能是current的右子节点，或者也可能是current右子节点的左子孙节点。下面来依次看看这两种情况。</p>
<p><strong>后继节点是delNode的右子节点</strong></p>
<p>如果后继是cunent的右子节点，情况就简单了一点，因为只需要把后继为根的子树移到删除的节点的位置。这个操作只需要两个步骤：</p>
<ol>
<li>把current从它父节点的rightChild字段删掉(当然也可能是leftChild字段)，把这个字段指向后继。</li>
<li>把current的左子节点移出来，把它插到后继的leftChild字段。</li>
</ol>
<p>下图演示了这种情况，要删除节点75，后继节点是其右节点</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/del_accessor_right.png" alt></p>
<p>接上之前的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">　　<span class="comment">//...接前面的else if</span></span><br><span class="line">　　<span class="keyword">else</span> &#123;</span><br><span class="line">　　　　<span class="comment">//查找后继节点</span></span><br><span class="line">　　　　Node&lt;T&gt; successor = getSuccessor(current);</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//情况3.1 如果如果删除节点有两个子节点且后继节点是删除节点的右子节点</span></span><br><span class="line">　　　　<span class="keyword">if</span> (current == root) &#123;</span><br><span class="line">　　　　　　root = successor;</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">　　　　　　parent.setLeftChild(successor);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　parent.setRightChild(successor);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　successor.setLeftChild(current.getLeftChild());</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一步：如果要删除的节点current是根，它没有父节点，所以就只需要把根置为后继。<br>否则，要删除的节点或者是左子节点或者是右子节点了(图8.19中它是右子节点)，因此<br>需要把它父节点的对应的字段指向successor。当delete()方法返回，current失去了作用范<br>围后，就没有引用指向current保存的节点，它就会被Java的垃圾收集机制销毁。</p>
<p>第二步：把successor的左子节点指向的位置设为current的左子节点。</p>
<p>如果后继有子节点怎么办呢？首先，后继节点是肯定不会有左子节点的。无论后继是要删除节<br>点的右子节点还是这个右子节点的左子节点之一，这条在查找后继节点的算法中可以验证。</p>
<p>另一方面，后继很有可能有右子节点。当后继是被删除节点的右子节点时，这种情况不会带来<br>多大问题。移动后继的时候，它的右子树只要跟着移动就可以了。这和要删除节点的右子节点没有<br>冲突，因为后继就是右子节点。</p>
<p>下面这种情况就需要很小心了。</p>
<p><strong>后继节点是delNode右子节点的左后代</strong></p>
<p>如果successor是要删除节点右子节点的左后代，执行删除操作需要以下四个步骤:</p>
<ol>
<li>把后继父节点的leftChild字段置为successor的右子节点。</li>
<li>把successor的rightChild字段置为要删除节点的右子节点。</li>
<li>把current从它父节点的rightChild字段移除，把这个字段置为successor</li>
<li>把current的左子节点从current移除，successor的leftChild字段置为current的左子节点。</li>
</ol>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/tree_del_successor_isLeft.png" alt></p>
<p>第1步和第2步由getSuccessor()方法完成(已经在前面写上了)，第3步和第4步由delete()方法完成。</p>
<h2 id="通过标记删除"><a href="#通过标记删除" class="headerlink" title="通过标记删除"></a>通过标记删除</h2><p>看到这里，删除操作已经全部完成了，真的是相当棘手的操作，难就难在节点的改变上。那么我们可不可以不改变节点，达到删除的目的？。</p>
<p>答案是可以的，在node类中加了一个Boolean的字段，名称如deleted。要删除一个节点时，就把此节点的这个字段置为true。其他操作，像find(),在查找之前先判断这个节点是不是标志为已删除了。</p>
<p>这样，删除的节点不会改变树的结构。当然，这样做存储中还保留着这种“己经删除”的节点。</p>
<p>如果树中没有那么多删除操作时，这也不失为一个好方法。（例如，已经离职的员工的档案要永久保存在员工记录中。）</p>
<p>下面是删除操作的完整代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">delete</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　Node&lt;T&gt; current = root;</span><br><span class="line">　　Node&lt;T&gt; parent = root;</span><br><span class="line">　　<span class="keyword">boolean</span> isLeftChild = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//删除操作第一步，查找要删除的节点</span></span><br><span class="line">　　<span class="keyword">while</span> (current.getIndex() != key) &#123;</span><br><span class="line">　　　　parent = current;</span><br><span class="line">　　　　<span class="keyword">if</span> (key &lt; current.getIndex()) &#123;</span><br><span class="line">　　　　　　isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">　　　　　　current = current.getLeftChild();</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">　　　　　　current = current.getRightChild();</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//如果左右节点均为null，没有找到要删除的元素</span></span><br><span class="line">　　　　<span class="keyword">if</span> (<span class="keyword">null</span> == current) &#123;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//跳出循环，找到要删除的元素:current</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (<span class="keyword">null</span> == current.getLeftChild() &amp;&amp; <span class="keyword">null</span> == current.getRightChild()) &#123;</span><br><span class="line">　　　　<span class="comment">//情况1：如果当前节点没有子节点</span></span><br><span class="line">　　　　<span class="keyword">if</span> (current == root) &#123;</span><br><span class="line">　　　　　　<span class="comment">//如果当前节点是根节点,将树清空</span></span><br><span class="line">　　　　　　root = <span class="keyword">null</span>;</span><br><span class="line">　　　　　　<span class="keyword">return</span> current;</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">　　　　　　<span class="comment">//如果当前节点是其父节点的做节点，将父节点的左节点清空</span></span><br><span class="line">　　　　　　parent.setLeftChild(<span class="keyword">null</span>);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　parent.setRightChild(<span class="keyword">null</span>);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == current.getRightChild()) &#123;</span><br><span class="line">　　　　<span class="comment">//情况2.1：如果删除节点只有一个子节点且没有右节点</span></span><br><span class="line">　　　　<span class="keyword">if</span> (current == root) &#123;</span><br><span class="line">　　　　　　root = current.getLeftChild();</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">　　　　　　parent.setLeftChild(current.getLeftChild());</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　parent.setRightChild(current.getLeftChild());</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == current.getLeftChild()) &#123;</span><br><span class="line">　　　　<span class="comment">//情况2.2 如果删除节点只有一个子节点且没有左节点</span></span><br><span class="line">　　　　<span class="keyword">if</span> (current == root) &#123;</span><br><span class="line">　　　　　　root = current.getRightChild();</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">　　　　　　parent.setLeftChild(current.getRightChild());</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　parent.setRightChild(current.getRightChild());</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　<span class="comment">//查找后继节点</span></span><br><span class="line">　　　　Node&lt;T&gt; successor = getSuccessor(current);</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//情况3.1 如果如果删除节点有两个子节点且后继节点是删除节点的右子节点</span></span><br><span class="line">　　　　<span class="keyword">if</span> (current == root) &#123;</span><br><span class="line">　　　　　　root = successor;</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">　　　　　　parent.setLeftChild(successor);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　parent.setRightChild(successor);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　successor.setLeftChild(current.getLeftChild());</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;T&gt; <span class="title">getSuccessor</span><span class="params">(Node&lt;T&gt; delNode)</span> </span>&#123;</span><br><span class="line">　　Node&lt;T&gt; successorParent = delNode;</span><br><span class="line">　　Node&lt;T&gt; successor = delNode;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//go to rightChild</span></span><br><span class="line">　　Node&lt;T&gt; current = delNode.getRightChild();</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">　　　　<span class="comment">//一直往下找左节点</span></span><br><span class="line">　　　　successorParent = successor;</span><br><span class="line">　　　　successor = current;</span><br><span class="line">　　　　current = current.getLeftChild();</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//跳出循环，此时successor为最后的一个左节点，也就是被删除节点的后继节点</span></span><br><span class="line"></span><br><span class="line">　　<span class="comment">//如果successor是要删除节点右子节点的左后代</span></span><br><span class="line">　　<span class="keyword">if</span> (successor != delNode.getRightChild()) &#123;</span><br><span class="line">　　　　<span class="comment">//把后继节点的父节点的leftChild字段置为successor的右子节点</span></span><br><span class="line">　　　　successorParent.setLeftChild(successor.getRightChild());</span><br><span class="line">　　　　<span class="comment">//把successor的rightChild字段置为要删除节点的右子节点。</span></span><br><span class="line">　　　　successor.setRightChild(delNode.getRightChild());</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二叉查找树的遍历"><a href="#二叉查找树的遍历" class="headerlink" title="二叉查找树的遍历"></a>二叉查找树的遍历</h3><p>前面说过二叉树的遍历主要有四种：前序遍历、后序遍历、层次遍历以及中序遍历。二叉搜索树最常用的遍历方法是中序遍历。</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历二叉搜索树会使所有的节点按关键字值升序被访问到。如果希望在二叉树中创建有序<br>的数据序列，这是一种方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node&lt;T&gt; localRoot)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (<span class="keyword">null</span> != localRoot) &#123;</span><br><span class="line">　　　　inOrder(localRoot.getLeftChild());</span><br><span class="line">　　　　System.out.println(localRoot.getIndex());</span><br><span class="line">　　　　inOrder(localRoot.getRightChild());</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/uncategorized/Java数据结构：数组/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/Java数据结构：数组/index.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T17:21:37+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/uncategorized/Java数据结构：数组/index.html" class="leancloud_visitors" data-flag-title>
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java数据结构：数组"><a href="#Java数据结构：数组" class="headerlink" title="Java数据结构：数组"></a>Java数据结构：数组</h1><h1 id="数组是什么"><a href="#数组是什么" class="headerlink" title="数组是什么"></a>数组是什么</h1><p>在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。</p>
<h1 id="Java中的数组"><a href="#Java中的数组" class="headerlink" title="Java中的数组"></a>Java中的数组</h1><p>在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。但是为这种速度所付出代价是数组对象大小被固定，并且在其声明周期中不可改变。</p>
<p>数组内的元素既可以是基本数据类型，也可以是引用数据类型。区别在于对象数据保存的是引用，基本类型数组直接保存基本类型的值。</p>
<h1 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个长度为2的int数组</span></span><br><span class="line"><span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//初始化一个保存1,2元素的数组</span></span><br><span class="line"><span class="keyword">int</span>[] intArr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//初始化一个保存1,2,3,4的数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个为初始化的数组，我们没办法做任何事情</span></span><br><span class="line">User[] userArr;</span><br><span class="line"><span class="comment">//声明一个长度为2的User类数组</span></span><br><span class="line">User[] user = <span class="keyword">new</span> User[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//初始化一个User数组，里面有两个User对象的引用</span></span><br><span class="line">userArr = <span class="keyword">new</span> User[] &#123;<span class="keyword">new</span> User(), <span class="keyword">new</span> User()&#125;;</span><br><span class="line"><span class="comment">//初始化一个User数组，里面有两个User对象的引用</span></span><br><span class="line">User[] userArr2 = &#123;<span class="keyword">new</span> User(), <span class="keyword">new</span> User()&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="数组是对象吗？"><a href="#数组是对象吗？" class="headerlink" title="数组是对象吗？"></a>数组是对象吗？</h1><p>Java里面的数组到底是什么？</p>
<p>答案是对象。</p>
<p>证据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">String name = arr.getClass().getSuperclass().getName();</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure></p>
<p>输出:java.lang.Object</p>
<p>数组的父类是Object。</p>
<p>Java数组这个对象太特俗了，以至于我们没办法把它当做对象处理，甚至我们都找不到类文件与之对应，但是找不到不代表没有。数组对象并不是从某个类实例化来的，而是由JVM直接创建的，因此查看类名的时候会发现是很奇怪的类似于”[I”这样的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = &#123;1, 2, 3, 4&#125;;</span><br><span class="line">String name = arr.getClass().getName();</span><br><span class="line">System.out.println(name);//</span><br><span class="line">输出：[I</span><br><span class="line"></span><br><span class="line">User[] userArr2 = &#123;new User(), new User()&#125;;</span><br><span class="line">String userArrClassName = userArr2.getClass().getName();</span><br><span class="line">System.out.println(userArrClassName);</span><br><span class="line">输出:[Lcom.weimai.medical.admin.controller.User;</span><br></pre></td></tr></table></figure>
<h1 id="length返回的是什么？"><a href="#length返回的是什么？" class="headerlink" title="length返回的是什么？"></a>length返回的是什么？</h1><p>length只表示数组能够容纳多少元素，也就是说，length是数组的大小，而不是实际存放的元素个数。</p>
<h1 id="Array类是做什么的？"><a href="#Array类是做什么的？" class="headerlink" title="Array类是做什么的？"></a>Array类是做什么的？</h1><p>我们点开Array类看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The &#123;@code Array&#125; class provides static methods to dynamically create and</span><br><span class="line"> * access Java arrays.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;&#123;@code Array&#125; permits widening conversions to occur during a get or set</span><br><span class="line"> * operation, but throws an &#123;@code IllegalArgumentException&#125; if a narrowing</span><br><span class="line"> * conversion would occur.</span><br><span class="line"> *</span><br><span class="line"> * @author Nakul Saraiya</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>首先看到这样一段注释，它的第一句就说明了Array类的作用：Array类提供静态方法来创建和访问Java数组。</p>
<p>再看下它的类声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final</span><br><span class="line">class Array &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>final类，不可修改。看到这里基本可以断定Array类和我们创建数组这个动作毫无关系，并且也不是真正的数组类。</p>
<p>正如类注释说明的那样，Array类可以帮助我们快速操作数组，它更像一个工具类，底层基本都是native方法。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//取数组索引为1的元素</span></span><br><span class="line">System.out.println(Array.get(arr, <span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="comment">//取数组索引为3的元素</span></span><br><span class="line">System.out.println(Array.get(arr, <span class="number">3</span>)); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<p>下面正式回答你的问题:<br>问题一：<br>　答案是没有关系，因为Array类是final的，Array类提供了一些静态方法帮助我们创建和访问数组。</p>
<p>问题二：<br>　在Java中，没有类文件与数组对应，数组是在JVM中动态生成的。</p>
<p>问题三：<br>　数组的长度，在动态生成的数组对象的对象头里有一个 _length 字段，记录数组长度。获取数组长度是由一条特定的指令arraylength实现。<br>　<br>　Array.getLength()和arr.length是一样的效果，代码验证如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//声明一个容量为2的数组</span><br><span class="line">int[] ints = new int[2];</span><br><span class="line">//指定索引0的值为1</span><br><span class="line">ints[0] = 1;</span><br><span class="line">System.out.println(ints.length); //2</span><br><span class="line">System.out.println(Array.getLength(ints); //2</span><br></pre></td></tr></table></figure></p>
<p>问题四：<br>　不知道你是指底层JVM的判断还是我们程序员自己判断。感觉应该是指底层JVM，很抱歉，水平有限，我也不清楚，但是感觉和底层的压栈出栈什么的有关系，不知道有没有使用length判断。</p>
<p>希望以上回答能帮到你，关注我的专栏<a href="https://zhuanlan.zhihu.com/stackjava" target="_blank" rel="noopener">Java技术栈</a>，让我们一起成长</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/uncategorized/Java集合之JDK1.8HashSet源码解析/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/Java集合之JDK1.8HashSet源码解析/index.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T17:21:37+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/uncategorized/Java集合之JDK1.8HashSet源码解析/index.html" class="leancloud_visitors" data-flag-title>
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面分析了ArrayList和HashMap的源码，今天分析下HashSet的源码。HashSet作为Java集合框架的一员，也是非常重要的，虽然平时用的没有前面两个多，但是在一些特定的场景可以帮助我们快速解决问题，所以掌握其特性也是非常重要的。</p>
<h1 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h1><p>首先还是先看下官方的类注释，快速了解HashSet的特性。</p>
<p>此类实现Set接口，由哈希表（实际上是HashMap实例）支持。它不能保证集合的迭代顺序;特别是，它不保证顺序一直保持不变。该类允许null元素。如果Hash函数能够很完美的分散各个元素到桶上，该类的基本操作（add, remove, contains and size）提供恒定的时间性能。</p>
<p>迭代此集合需要的时间与HashSet实例的大小（元素数量）以及HashMap实例的“容量”（桶数）之和成比例。因此，如果迭代性能很重要，则不要将初始容量设置得太高（或负载因子太低）。请注意，此实现不同步。如果多个线程同时访问哈希集合，并且至少有一个线程修改了该即可，则必须在外部进行同步。这通常通过在自然封装集合的某个对象上进行同步来实现。如果不存在此类对象，则应使用Collections.synchronizedSet方法“包装”该集合。这最好在创建时完成，以防止对集合的意外不同步访问：Set s = Collections.synchronizedSet（new HashSet（…））;</p>
<p>这个类的迭代器方法返回的迭代器是快速失败的：如果在创建迭代器之后的任何时候修改了set，​​除了通过迭代器自己的remove方法之外，Iterator都将抛出ConcurrentModificationException。因此，在并发修改的情况下，迭代器快速而干净地失败，而不是在未来的未确定时间冒着任意的，非确定性行为的风险。</p>
<p>请注意，迭代器的快速失败行为无法阿紫存在不同步的并发修改时做出任何硬性保证。快速失败迭代器会尽最大努力抛出ConcurrentModificationException。因此，不要编写这个异常的程序：迭代器的快速失败行为应仅用于检测错误。</p>
<p>由于HashSet的底层是HashMap,它的类注释和HashMap差不多，其特性也和HashMap差不多。</p>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>同HashMap一样，HashSet也有4个构造方法</p>
<p><strong>HashSet()</strong><br>构建一个空的set集合，其底层的HashMap实例使用默认的初始容量(16)和加载因子(0.75)。</p>
<p><strong>HashSet(Collection&lt;? extends E&gt; c)</strong><br>使用其他集合创建一个新得HashSet</p>
<p><strong>HashSet(int initialCapacity)</strong><br>构建一个空的set集合，其底层的HashMap实例使用传入的初始容量和默认加载因子(0.75)。</p>
<p><strong>HashSet(int initialCapacity, float loadFactor)</strong><br>构建一个空的set集合，其底层的HashMap实例使用传入的初始容量和加载因子。</p>
<p>我们看一下第一个和第四个构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个空的set集合，其底层的HashMap实例使用默认的初始容量(16)和加载因子(0.75)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个空的set集合，其底层的HashMap实例使用传入的初始容量和加载因子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      initialCapacity   初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      loadFactor        加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment"> *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放元素的map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap的value值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<h1 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h1><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将元素放到map中，key是要添加的元素e，value是final修饰的object对象。</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从HashMap中移除元素o，如果元素存在返回true，否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回HashMap中元素的个数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of elements in this set (its cardinality)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断HashMap中是否包含某个元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element whose presence in this set is to be tested</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断HashSet是否是空的</span><br><span class="line"> *</span><br><span class="line"> * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements</span><br><span class="line"> */</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">    return map.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>底层调用的是HashMap的isEmpty方法，实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ArrayList和HashSet的区别"><a href="#ArrayList和HashSet的区别" class="headerlink" title="ArrayList和HashSet的区别"></a>ArrayList和HashSet的区别</h1><p>比较ArrayList和HashSet的区别，其实也是比较ArrayList和HashMap的区别</p>
<ol>
<li>ArraysList是有序的，元素可以重复。HashSet无序，元素不可重复。</li>
<li>ArrayList底层是一个数组，HashSet底层是一个HashMap，HashMap的底层又是数组+链表+红黑树</li>
<li>ArrList在数组被填充满之后才会扩容，扩容到原来的1.5倍+1.HashSet和HashMap一样，扩容的实际和加载因子有关，扩容到原来的2倍</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>HashSet的底层其实是一个HashMap，key是我们存放的元素，其value是一个final修饰的object对象</li>
<li>HashSet是无序的，和HashMap一样。</li>
<li>HashSet也是线程不安全的，我们可以使用Set s = Collections.synchronizedSet（new HashSet（…））包装一个线程安全的Set</li>
<li>HashSet中的元素不可重复，因为HashMap中的key不可重复，重复的key会覆盖其value。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/consectetur/malesuada/Java集合之JDK1.8LinkedHashMap源码解析/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/consectetur/malesuada/Java集合之JDK1.8LinkedHashMap源码解析/index.html" itemprop="url">Java集合之JDK1.8LinkedHashMap源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T17:21:37+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/consectetur/index.html" itemprop="url" rel="index">
                    <span itemprop="name">consectetur</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/consectetur/malesuada/index.html" itemprop="url" rel="index">
                    <span itemprop="name">malesuada</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/consectetur/malesuada/Java集合之JDK1.8LinkedHashMap源码解析/index.html" class="leancloud_visitors" data-flag-title="Java集合之JDK1.8LinkedHashMap源码解析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>LinkedHashMap实现了Map接口继承至HashMap，它在HashMap的基础上，通过一条双向链表是插入顺序和访问顺序保持一致。LinkedHashMap除了对双向链表的维护外，基本都是对HashMap的操作，所以在看LinkedHashMap源码之前，强烈建议先看看HashMap的源码,可以参考我的这一篇：<a href="https://zhuanlan.zhihu.com/p/72296421" target="_blank" rel="noopener"></a></p>
<p>本篇文章不会再详细解析HashMap的东西，将重点放在LinkedHashMap对双向链表的维护上。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>照例从创建LinkedHashMap对象说起，依次为起点，一步步解开LinkedHashMap的神秘面纱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">　LinkedHashMap()</span><br><span class="line">　使用默认初始容量<span class="number">16</span>和默认加载因子<span class="number">0.75</span>创建一个LinkedHashMap</span><br><span class="line">　LinkedHashMap(<span class="keyword">int</span> initialCapacity)</span><br><span class="line">　使用自定义初始容量和默认加载因子<span class="number">0.75</span>创建一个LinkedHashMap</span><br><span class="line">　LinkedHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span><br><span class="line">　使用自定义初始容量和自动以加载因子创建一个LinkedHashMap</span><br><span class="line">　LinkedHashMap(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span><br><span class="line">　使用自定义初始容量和自动以加载因子创建一个LinkedHashMap,并且可以设置accessOrder,accessOrder为<span class="keyword">true</span>，调用get方法会改变内部结构，这一点后面会细讲</span><br><span class="line">　LinkedHashMap(Map&lt;? extends K,? extends V&gt; m)</span><br><span class="line">　使用Map子类实例创建一个LinkedHashMap</span><br></pre></td></tr></table></figure>
<h2 id="LinkedHashMap-无参构造"><a href="#LinkedHashMap-无参构造" class="headerlink" title="LinkedHashMap() 无参构造"></a>LinkedHashMap() 无参构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//调用父类HashMap构造方法</span></span><br><span class="line">　　<span class="keyword">super</span>();</span><br><span class="line">　　<span class="comment">//accessOrder默认为false</span></span><br><span class="line">　　accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkedHashMap-int-initialCapacity-float-loadFactor-自定义初始容量和加载因子"><a href="#LinkedHashMap-int-initialCapacity-float-loadFactor-自定义初始容量和加载因子" class="headerlink" title="LinkedHashMap(int initialCapacity, float loadFactor)自定义初始容量和加载因子"></a>LinkedHashMap(int initialCapacity, float loadFactor)自定义初始容量和加载因子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//调用父类HashMap构造方法</span></span><br><span class="line">　　<span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">   <span class="comment">//accessOrder默认为false</span></span><br><span class="line">　　accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedHashMap和HashMap的构造方法差不多，区别在于多了一个accessOrder，接下来看看这个字段起什么作用。</p>
<h1 id="accessOrder"><a href="#accessOrder" class="headerlink" title="accessOrder"></a>accessOrder</h1><p>点开accessOrder的调用处，发现除了构造方法外，只有3处使用了accessOrder字段,分别是get()方法,getOrDefault()方法和afterNodeAccess（）方法。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/accessOrder.png" alt></p>
<p>get()方法我们比较熟悉，先看下get()方法的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">　　Node&lt;K,V&gt; e;</span><br><span class="line">　　<span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">//如果accessOrder为true，调用afterNodeAccess()方法,传入get()方法取出的节点e</span></span><br><span class="line">　　<span class="keyword">if</span> (accessOrder)</span><br><span class="line">　　　　afterNodeAccess(e);</span><br><span class="line">　　<span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下afterNodeAccess()方法的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">   <span class="comment">//声明最后一个节点last</span></span><br><span class="line">　　LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">   <span class="comment">//如果accessOrder为true并且最后一个节点tail不等于get()方法取出的节点e</span></span><br><span class="line">　　<span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">       <span class="comment">//将e复制给p,取出p的前节点和后节点分别复制给b和a</span></span><br><span class="line">　　　　LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">　　　　　　(LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">      <span class="comment">//将p的后节点置为null</span></span><br><span class="line">　　　　p.after = <span class="keyword">null</span>;</span><br><span class="line">　　　　<span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">　　　　　　head = a;</span><br><span class="line">　　　　<span class="keyword">else</span></span><br><span class="line">　　　　　　b.after = a;</span><br><span class="line">　　　　<span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">　　　　　　a.before = b;</span><br><span class="line">　　　　<span class="keyword">else</span></span><br><span class="line">　　　　　　last = b;</span><br><span class="line">　　　　<span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">　　　　　　head = p;</span><br><span class="line">　　　　<span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　p.before = last;</span><br><span class="line">　　　　　　last.after = p;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　tail = p;</span><br><span class="line">　　　　++modCount;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tail是LinkedHashMap的成员变量,保存的是一份最新的节点数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">　* The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">　*/</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure></p>
<p>有最新的便有最老的，LinkedHashMap中使用head变量保存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">　* The head (eldest) of the doubly linked list.</span><br><span class="line">　*/</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的代码并不复杂，不一一解释了，我么只需要知道最终的效果是将get()方法取出的节点，放到了链表的最后，使之成为尾部节点，从而改变了数据在LinkedHashMap中的存储顺序，它的迭代顺序就是最后访问其条目的顺序。这种特性很适合构建LRU Cache</p>
<h2 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h2><h3 id="什么是LRU？"><a href="#什么是LRU？" class="headerlink" title="什么是LRU？"></a>什么是LRU？</h3><p>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。 </p>
<p>实现 LRU 算法除了需要 key/value 字典外，还需要附加一个链表，链表中的元素按照一定的顺序进行排列。当空间满的时候，会踢掉链表尾部的元素。当字典的某个元素被访问时，它在链表中的位置会被移动到表头。所以链表的元素排列顺序就是元素最近被访问的时间顺序。</p>
<p>位于链表尾部的元素就是不被重用的元素，所以会被踢掉。位于表头的元素就是最近刚刚被人用过的元素，所以暂时不会被踢。</p>
<p>看了这里的描述，有人可能会疑惑，链表尾部的元素会被踢掉。这和LinkedHashMap似乎正好矛盾，因为LinkedHashMap是将最近访问的元素放到末尾。</p>
<p>注意，链表的双向的，头部和尾部的确定取决于我们代码的上下文。</p>
<p>拓展:Redis在内存过高的时候可以对key进行淘汰，Redis 提供了几种可选策略 (maxmemory-policy) 来让用户自己决定该如何腾出新的空间以继续提供读写服务。</p>
<p>这几种策略的其中之一便有LRU：</p>
<p>volatile-lru 尝试淘汰设置了过期时间的 key，最少使用的 key 优先被淘汰。没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。</p>
<h1 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h1><p>LinkedHashMap的put()方法继承至HashMap,没有进行重写。此处不再赘述HashMap的put()方法。LinkedHashMap对创建节点的方法进行了重写</p>
<h2 id="new-Node-重写"><a href="#new-Node-重写" class="headerlink" title="new Node()重写"></a>new Node()重写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">　　<span class="comment">//创建一个LinkedHashMap.Entry对象</span></span><br><span class="line">　　LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">　　　　<span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">   <span class="comment">//将p放到链表的最后</span></span><br><span class="line">　　linkNodeLast(p);</span><br><span class="line">　　<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedHashMap.Entry是LinkedHashMap的静态内部类，它就是所谓的双向链表,继承至HashMap.Node类，并在此基础上扩展了两个属性:前节点和后节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">　* HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">　*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">　　<span class="comment">//定义了两个变量，分别是当前节点的前一个节点和后一个节点</span></span><br><span class="line">　　Entry&lt;K,V&gt; before, after;</span><br><span class="line">　　Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">　　　　<span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看下linkNodeLast的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将tail保存一份</span></span><br><span class="line">LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line"><span class="comment">//将最新的节点p赋值给tail</span></span><br><span class="line">tail = p;</span><br><span class="line"><span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">　　<span class="comment">//如果链表是空的，将p放在链表头部</span></span><br><span class="line">　　head = p;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">　　<span class="comment">//如果链表不为空，将p放到链表的尾部</span></span><br><span class="line">　　p.before = last;</span><br><span class="line">　　last.after = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h1><p>LinkedHashMap对HashMap的get()方法进行了重写，区别在前面已经说过，主要就是accessOrder字段。如果我们设置了accessOrder字段为true，那么get()方法在获得数据之后，会将该数据节点放置链表的最后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">　　Node&lt;K,V&gt; e;</span><br><span class="line">　　<span class="comment">//调用HashMap的getNode()方法获取数据</span></span><br><span class="line">　　<span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">　　<span class="keyword">if</span> (accessOrder)</span><br><span class="line">　　　　afterNodeAccess(e);</span><br><span class="line">　　<span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h1><p>对于remove方法，在LinkedHashMap中也没有重写，它调用的还是父类的HashMap的remove()方法，在LinkedHashMap中重写的是：afterNodeRemoval(Node&lt;K,V&gt; e)这个方法，在Hash表的元素被删除之后，删除双向链表的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">　　LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">　　　　(LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">　　p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">　　<span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">　　　　head = a;</span><br><span class="line">　　<span class="keyword">else</span></span><br><span class="line">　　　　b.after = a;</span><br><span class="line">　　<span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">　　　　tail = b;</span><br><span class="line">　　<span class="keyword">else</span></span><br><span class="line">　　　　a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Iterator遍历"><a href="#Iterator遍历" class="headerlink" title="Iterator遍历"></a>Iterator遍历</h1><p>LinkedHashMap重写了entrySet()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">　　Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">　　return (es = entrySet) == null ? (entrySet = new LinkedEntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LinkedHashMap实际上是对双向链表LinkedHashMap.Entry遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">abstract class LinkedHashIterator &#123;</span><br><span class="line">　　LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class="line">　　LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class="line">　　int expectedModCount;</span><br><span class="line"></span><br><span class="line">　　LinkedHashIterator() &#123;</span><br><span class="line">　　　　next = head;</span><br><span class="line">　　　　expectedModCount = modCount;</span><br><span class="line">　　　　current = null;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　public final boolean hasNext() &#123;</span><br><span class="line">　　　　return next != null;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123;</span><br><span class="line">       //遍历双向链表</span><br><span class="line">　　　　LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">　　　　if (modCount != expectedModCount)</span><br><span class="line">　　　　　　throw new ConcurrentModificationException();</span><br><span class="line">　　　　if (e == null)</span><br><span class="line">　　　　　　throw new NoSuchElementException();</span><br><span class="line">　　　　current = e;</span><br><span class="line">　　　　next = e.after;</span><br><span class="line">　　　　return e;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　public final void remove() &#123;</span><br><span class="line">　　　　Node&lt;K,V&gt; p = current;</span><br><span class="line">　　　　if (p == null)</span><br><span class="line">　　　　　　throw new IllegalStateException();</span><br><span class="line">　　　　if (modCount != expectedModCount)</span><br><span class="line">　　　　　　throw new ConcurrentModificationException();</span><br><span class="line">　　　　current = null;</span><br><span class="line">　　　　K key = p.key;</span><br><span class="line">　　　　removeNode(hash(key), key, null, false, false);</span><br><span class="line">　　　　expectedModCount = modCount;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>LinkedHashMap通过在HashMap的基础上增加一条双向链表，实现了插入顺序和访问顺序一致。实现的核心是静态内部类LinkedHashMap.Entry，LinkedHashMap.Entry继承至HashMap的静态内部类HashMap.Node。Entry拥有Node的所有属性，并且在此基础上增加了前节点和后节点两个属性。所有对底层HashMap数据结构修改的地方都会修改该链表进行修改,遍历的时候便是遍历这一条有序的链表。需要注意的是get()方法在accessOrder为true的时候也会对底层结构进行修改。</li>
<li>基于get()在accessOrder为true时，会将访问到的元素放到链表的最后的特性，我们可以使用LinkedHashMap实现LRU缓存。</li>
<li>LinkedHashMap同HashMap一样，线程不安全</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/uncategorized/Sharding-JDBC系列之Springboot2中使用Shariding-JDBC分库分表/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/Sharding-JDBC系列之Springboot2中使用Shariding-JDBC分库分表/index.html" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T17:21:37+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/uncategorized/Sharding-JDBC系列之Springboot2中使用Shariding-JDBC分库分表/index.html" class="leancloud_visitors" data-flag-title>
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在工作中使用Sharding-JDBC做了分库分表，目前项目已经上线并稳定运行，闲暇时于记录下使用过程以及踩过的坑，希望对准备使用Sharding-JDBC做分库分表的同学有些帮助。</p>
<h1 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h1><p>随着业务的发展，数据量也是爆炸式的增长，有的表结构数据量已经过亿，并且以每月几百万的量持续增长。已经到了必须分库分表的地步。正好我们的系统也要进行服务拆分，一个服务拆分为四个服务，于是一起将分库分表也做掉了。</p>
<h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>在决定分库分表之后，首先要做的便是技术选型，目前市面上用来分库分表的中间件有很多，比如Mycat、Sharding-JDBC、淘宝的TDDL（未开源）、平明软件的OneProxy（收费）、360的Atlas、Youtube的Vitess，还有最近比较流行的TiDB等等。</p>
<p>在选择中间件之前，首先得了解分库分表中间件的切入时机</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/382306343-5c07cde261b29_articlex.png" alt><br>1.编码层</p>
<p> 在同一个项目中创建多个数据源，采用if else的方式，直接根据条件在代码中路由。</p>
<p>  缺点：</p>
<p> 1.编写大量代码</p>
<p> 2.代码无法公用</p>
<p>2.框架层</p>
<p> 适合公司ORM框架统一的情况，通过修改或增强现有ORM框架的功能来实现</p>
<p>3.驱动层</p>
<p> 重新编写了一个JDBC的驱动，在内存中维护一个路由列表，然后将请求转发到真正的数据库连接中。例如：Sharding-JDBC、TDDL等</p>
<p>4.代理层</p>
<p> 伪装成一个数据库，接受业务端的链接。然后负载业务端的请求，解析或者转发到真正的数据库中。例如MyCat、MySQL Router、Sharding-Proxy</p>
<p>5.实现层<br>更换底层的数据存储，比如Mysql替换为TiDB。</p>
<p>传统的分库分表，通常是在驱动层和代理层做切入，这两个各有优劣，不过在将驱动层和代理层的区别前，先说一下TiDB。</p>
<h2 id="TiDB"><a href="#TiDB" class="headerlink" title="TiDB"></a>TiDB</h2><p>TiDB是公司一位大佬推荐的，了解一番后发现这个数据库很方便快捷的帮我们解决海量数据存储这件事情，如果能用TiDB代替传统的分库分表方案也是很好的，可以节省很多时间。不过由于这个数据库只在公司大数据部门的OLAP系统有应用，而实时性要求较高的OLTP系统目前还没有应用，所以决定对TiDB系统进行一次压测，看看其能否满足线上的要求。</p>
<p>压测的过程不多赘述，最终的结果页不是很理想，因为有这么一个怪现象：在持续高并发的情况下，会出现莫名其妙的连接超时失败。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/%E5%9B%BE%E7%89%871.png" alt></p>
<p>对于这一结果，我们百思不得其解，对结果的准确性也保持的怀疑的态度。但是由于时间有限，不允许我们继续测试，只得将目光投向了其他中间件，同时也和官方联系，询问原因。</p>
<p>后面官方给出的说法是这样的：由于我们的内存配置的太小(8g)，导致持续 高并发的时候会进行内存回收，这个时候会强制断开连接。并且给我们介绍说目前实现上OLTP系统中应用TiDB内存都是258g，集群3台机器以上。好吧，都是土豪，惹不起。</p>
<h2 id="Sharding-JDBC和Mycat"><a href="#Sharding-JDBC和Mycat" class="headerlink" title="Sharding-JDBC和Mycat"></a>Sharding-JDBC和Mycat</h2><p>排序TiDB后，便只能使用传统的分库分表方案，国内比较火的便是Sharding-JDBC和Mycat，这两个正是驱动层和代理层的代表。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/Driver%E5%92%8CProxy.png" alt></p>
<p>相对于Mycat，仅仅是一个Jar包的Sharding-JDBC赢了我的青睐。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/Sharding-JDBC.png" alt></p>
<h1 id="Sharding-JDBC在SpringBoot2中的应用。"><a href="#Sharding-JDBC在SpringBoot2中的应用。" class="headerlink" title="Sharding-JDBC在SpringBoot2中的应用。"></a>Sharding-JDBC在SpringBoot2中的应用。</h1><p>Sharidng-JDBC最早起源于当当，后来进入了Apache孵化器，变为了Sharding-Sphere，目前最新的版本是<a href="https://github.com/apache/incubator-shardingsphere/releases/tag/4.0.0-RC1" target="_blank" rel="noopener">4.0.0-RC1</a>。</p>
<h2 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h2><p>官方的文档并没有写明白Springboot项目应该如何引入依赖，好在机智的我在官方案例中找到了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.0-RC1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="配置数据源以及分库分表规则"><a href="#配置数据源以及分库分表规则" class="headerlink" title="配置数据源以及分库分表规则"></a>配置数据源以及分库分表规则</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  shardingsphere:</span></span><br><span class="line"><span class="attr">    datasource:</span></span><br><span class="line"><span class="attr">      master0:</span> <span class="comment"># 主库连接信息</span></span><br><span class="line"><span class="attr">        driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">        jdbc-url:</span> <span class="attr">jdbc:mysql://$&#123;your</span> <span class="string">database</span> <span class="string">ip&#125;:3306/$&#123;your</span> <span class="string">database</span> <span class="string">name&#125;?Unicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=true</span></span><br><span class="line"><span class="attr">        password:</span> <span class="string">your</span> <span class="string">password</span></span><br><span class="line"><span class="attr">        type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">        username:</span> <span class="string">your</span> <span class="string">username</span></span><br><span class="line"><span class="attr">      master0slave0:</span> <span class="comment"># 从库连接信息</span></span><br><span class="line"><span class="attr">        driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">        jdbc-url:</span> <span class="attr">jdbc:mysql://$&#123;your</span> <span class="string">database</span> <span class="string">ip&#125;:3306/$&#123;your</span> <span class="string">database</span> <span class="string">name&#125;?Unicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=true</span></span><br><span class="line"><span class="attr">        password:</span> <span class="string">your</span> <span class="string">password</span></span><br><span class="line"><span class="attr">        type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">        username:</span> <span class="string">your</span> <span class="string">username</span></span><br><span class="line"><span class="attr">      names:</span> <span class="string">master0,master0slave0</span> <span class="comment"># 连接名称，和上面对应。如果有多个主库则配置master1,master1slave1，名字可以随便起，对应起来就好</span></span><br><span class="line"><span class="attr">    sharding:</span></span><br><span class="line"><span class="attr">      broadcast-tables:</span> <span class="comment"># 配置广播表，适合数据量不大，但是每个数据源都存在的表</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">xtgy_chaxunympz</span></span><br><span class="line"><span class="attr">      default-data-source-name:</span> <span class="string">master0</span> <span class="comment">#默认数据源，没有配置分库分表规则的表，会使用默认数据源</span></span><br><span class="line"><span class="attr">      master-slave-rules:</span> <span class="comment">#配置主从规则 </span></span><br><span class="line"><span class="attr">        master0:</span></span><br><span class="line"><span class="attr">          master-data-source-name:</span> <span class="string">master0</span></span><br><span class="line"><span class="attr">          slave-data-source-names:</span> <span class="string">master0slave0</span></span><br><span class="line"><span class="attr">      tables:</span> <span class="comment">#配置各表的路由规则</span></span><br><span class="line"><span class="attr">        table_name:</span> <span class="comment">#表名</span></span><br><span class="line"><span class="attr">          actual-data-nodes:</span> <span class="string">master0.table_name_$-&gt;&#123;0..127&#125;</span> <span class="comment">#实际表名 table_name_0 至 table_name_127</span></span><br><span class="line"><span class="attr">          key-generator:</span> <span class="comment">#主键生成策略</span></span><br><span class="line"><span class="attr">            column:</span> <span class="string">id</span></span><br><span class="line"><span class="attr">            type:</span> <span class="string">UUID</span></span><br><span class="line"><span class="attr">          table-strategy:</span> <span class="comment">#分表规则</span></span><br><span class="line"><span class="attr">            inline:</span></span><br><span class="line"><span class="attr">              algorithm-expression:</span> <span class="string">table_name_$-&gt;&#123;customer_id</span> <span class="string">%</span> <span class="number">128</span><span class="string">&#125;</span> <span class="comment">#customer_id %128</span></span><br><span class="line"><span class="attr">              sharding-column:</span> <span class="string">customer_id</span> <span class="comment">#用于分表的键</span></span><br></pre></td></tr></table></figure>
<h2 id="允许Bean覆盖"><a href="#允许Bean覆盖" class="headerlink" title="允许Bean覆盖"></a>允许Bean覆盖</h2><p>SpringBoot2默认不允许Bean覆盖，我们需要改成允许，不然<strong>可能</strong>会报错</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  main:</span></span><br><span class="line"><span class="attr">    allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>到这里，配置便完成了，是不是很简单？如果你的数据库和表结构都已经创建，就可以开始体验了。后面会介绍Sharding-JDBC的一些特性，已经源码解析。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/overview/</a></p>
<p><a href="https://segmentfault.com/a/1190000017272697" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017272697</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/consectetur/malesuada/TODO：Redis主从复制详解/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/consectetur/malesuada/TODO：Redis主从复制详解/index.html" itemprop="url">Lorem ipsum</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T17:21:37+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/consectetur/index.html" itemprop="url" rel="index">
                    <span itemprop="name">consectetur</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/consectetur/malesuada/index.html" itemprop="url" rel="index">
                    <span itemprop="name">malesuada</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/consectetur/malesuada/TODO：Redis主从复制详解/index.html" class="leancloud_visitors" data-flag-title="Lorem ipsum">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="$appres/images/night.jpg" alt="Nulla euismod, vitae aliquet orci eleifend."></p>
<h1 id="Lorem-ipsum"><a href="#Lorem-ipsum" class="headerlink" title="Lorem ipsum"></a>Lorem ipsum</h1><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus eu tempor dolor. Nulla hendrerit convallis purus et elementum. Suspendisse non magna vel justo tincidunt finibus. Nullam dui erat, malesuada eget viverra non, finibus a nisl.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/Sharding-JDBC/TODO：Sharding-JDBC源码解析/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Sharding-JDBC/TODO：Sharding-JDBC源码解析/index.html" itemprop="url">Sharding-JDBC源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T17:21:37+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Sharding-JDBC/index.html" itemprop="url" rel="index">
                    <span itemprop="name">Sharding-JDBC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/Sharding-JDBC/TODO：Sharding-JDBC源码解析/index.html" class="leancloud_visitors" data-flag-title="Sharding-JDBC源码解析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在工作中使用Sharding-JDBC做了分库分表，目前项目已经上线稳定运行，闲暇之余看下源码。</p>
<p>版本:4.0.0-RC1</p>
<p>由于现在基本都是springboot，而Sharding-Sphere也提供了SpringBoot的包，所以先看看sharding-jdbc-spring-boot-starter的源码，maven坐标:</p>
<p><dependency><br>   <groupid>org.apache.shardingsphere</groupid><br>   <artifactid>sharding-jdbc-spring-boot-starter</artifactid><br>   <version>${sharding-sphere.version}</version><br> </dependency><br> &lt;sharding-sphere.version&gt;4.0.0-RC1&lt;/sharding-sphere.version&gt;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/面试/java面试宝典/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/面试/java面试宝典/index.html" itemprop="url">java面试宝典</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T17:21:37+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/index.html" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/面试/java面试宝典/index.html" class="leancloud_visitors" data-flag-title="java面试宝典">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="前言-做好面试前的准备工作"><a href="#前言-做好面试前的准备工作" class="headerlink" title="前言 做好面试前的准备工作"></a>前言 做好面试前的准备工作</h1><h1 id="第一部分-Java基础"><a href="#第一部分-Java基础" class="headerlink" title="第一部分 Java基础"></a>第一部分 Java基础</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="static-关键字的作用"><a href="#static-关键字的作用" class="headerlink" title="static 关键字的作用?"></a>static 关键字的作用?</h4><p>static关键字可以让我们在不创建对象的情况下访问方法或变量。static除了可以修饰方法和变量外，还有static代码块，以及修饰内部类。被static修饰的数据，在内存中只会存在一份。合理利用static合理提升程序性能</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/面试/java面试宝典/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/mysql/TODO：事务特性以及Mysql事务的实现/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/mysql/TODO：事务特性以及Mysql事务的实现/index.html" itemprop="url">事务特性以及Mysql事务的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T15:01:18+08:00">
                2019-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/index.html" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/mysql/TODO：事务特性以及Mysql事务的实现/index.html" class="leancloud_visitors" data-flag-title="事务特性以及Mysql事务的实现">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h1><p>事务是数据库区别于文件系统的重要特征之一。事务用来保证数据库的完整性–要么都做修改，要么都不做。同时，事务有严格的定义，它必须同时满足四个特性。</p>
<p><strong>原子性</strong></p>
<p>原子性是指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作执行都成功，才算整个事务成功。如果事务中任何一个SQL语句执行失败，那么已经执行 成功的SQL语句也必须撒销，数据库状态应该退回到执行事务前的状态。 </p>
<p><strong>一致性(consistency)</strong> </p>
<p>一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务 结束以后，数据库的完整性约束没有被破坏。</p>
<p><strong>隔离性(isolation)</strong> </p>
<p>一个事务的影响在该事务提交前对其他事务都不可见——这通过锁来实现</p>
<p><strong>持久性(durability)</strong> </p>
<p>事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。 </p>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>了解事务隔离级别前，先介绍下数据库在并发读取数据产生的问题。</p>
<p><strong>脏读</strong></p>
<p>一个事务可以读到了另外一个还没有提交（commit）事务的数据。</p>
<p>举个例子：<br>       公司发工资了，把50000元打到我的账号上，但是该事务并未提交，而我正好去查看账户，发现工资已经到账，是50000元整，非常高兴。可是不幸的是，领导发现发给的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后我实际的工资只有2000元，空欢喜一场。</p>
<p>脏读是两个并发的事务，“事务A：领导发工资”、“事务B：我查询工资账户”，事务B读取了事务A尚未提交的数据。</p>
<p><strong>不可重复读</strong></p>
<p>一个事务A需要多次读取一个数据，在这个事务还没有提交前，存在另外的事务B对改数据进行了修改，导致事务A前后读取的数据不一致。</p>
<p><strong>幻读</strong></p>
<p>事务A需要修改表中的所有数据行，与此同时，事务B需要往表中插入新的数据。事务A在修改完毕后发现还有数据没有被修改，就好象发生了幻觉一样。</p>
<p>ISO和ANIS SQL标准制定了四种事务隔离级别。</p>
<p><strong>READ UNCOMMITTED</strong><br>在这一隔离级别，一个事务可以读到另外一个还没有提交（commit）的事务。脏读，不可重复度，幻读都有可能发生。</p>
<p><strong>READ COMMITTED</strong> </p>
<p>该级别比READ UNCOMMITTED高一级，只能读取到事务已经提交的数据，它解决了脏读的问题，但是不能解决不可重复度，幻读。它是Oracle数据库的默认隔离级别。</p>
<p><strong>REPEATABLE READ</strong> </p>
<p><strong>SERIALIZABLE</strong></p>
<p>READ UNCOMMITTED称为浏览访问(browse access),仅仅只对事务而言的。<br>READ COMMITTED称为游标稳定(cursor stability)。<br>REPEATABLE READ是2.9999°的 隔离，没有幻读的保护。<br>SERIALIZABLE称为隔离，或3’。SQL和SQL 2标准的默认事务 隔离级别是SERIALIZABLE。 </p>
<p>InnoDB存储引擎默认的支持隔离级别是REPEATABLE READ,但是与标准SQL不同 的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock锁的 算法，因此避免幻读的产生。这与其他数据库系统(如Microsoft SQL Server数据库)是不 同的。所以说，InnoDB存储引擎在默认REPEATABLE READ的事务隔离级别下已经能完全保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE隔离级别。 </p>
<p>隔离级别越低，事务请求的锁越少，或者保持锁的时间就越短。这也是为什么大多数 数据库系统默认的事务隔离级别是READ COMMITTED。</p>
<h1 id="Mysql事务的实现"><a href="#Mysql事务的实现" class="headerlink" title="Mysql事务的实现"></a>Mysql事务的实现</h1><p>在Mysql中原子性、一致性、持久性通过数据库的redo和undo 来完成。隔离性用锁实现。</p>
<h2 id="隔离性的实现"><a href="#隔离性的实现" class="headerlink" title="隔离性的实现"></a>隔离性的实现</h2><p>隔离性由第6章讲述的锁得以实现。<br>7.2.1    redo<br>在InnoDB存储引擎中，事务日志通过重做(redo)日志文件和InnoDB存储引擎的日志 缓冲(InnoDB Log Buffer)来实现。当开始一个事务时，会记录该事务的一个LSN  (Log<br>Sequence Number,日志序列号)，当事务执行时，会往InnoDB存储引擎的日志缓冲里插<br>入事务日志I当事务提交时，必须将InnoDB存储引擎的日志缓冲写入磁盘(默认的实现， 即innodb_flush_log_at_trx_commit= 1)。也就是在写数据前，需要先写日志。这种方式称 为预写日志方式(Write-Ahead Logging, WAL)。<br>InnoDB存储引擎通过预写日志的方式来保证事务的完整性。这意味着磁盘上存储的数<br>据页和内存缓冲池中的页是不同步的，对于内存缓冲池中页的修改，先是写入重做日志文<br>件，然后再写入磁盘，因此是一种异步的方式。可以通过命令SHOW ENGINE INNODB STATUS来观察当前磁盘和日志的“差距”：<br>create table z (a int,primary key(a))engine-innodb;</p>
<p>create procedure load_test (count int)<br>begin<br>declare i int unsigned default 0;<br>start transaction;<br>while i &lt; count do<br>insert into z select i;<br>set i=i+l;<br>end while;<br>conunit;<br>end;<br>首先建立一张表z，然后建立一个往表z中导入数据的存储过程load_test0通过命令 SHOW ENGINE INNODB STATUS观察当前的重做日志情况：<br>mysql&gt; show engine innodb status\G;<br>……<br>LOG</p>
<p>1 row in set (0.00 sec)<br>Log sequence number表示当前的LSN, Log flushed up to表示刷新到重做日志文件的 LSN, Last checkpoint at表示刷新到磁盘的LSN。因为当前没有任何操作，所以这三者的 值是一样的。接着开始导入10 000条记录：<br>mysql&gt;call load_test(10000);<br>mysql&gt; show engine innodb status\G;</p>
<p>这次SHOW ENGINE INNODB STATUS的结果就不同了，Log sequence number的LSN<br>为113047672789, Log flushed up to的LSN为113047672789, Last checkpoint at的LSN为 113047174608,可以把Log flushed up to和Last checkpoint at的差值498 181 (-486.5K)理 解为重做日志产生的增量(以字节为单位)。<br>虽然在上面的例子中，Log sequence number和Log flushed up to的值是相等的，但是在<br>实际的生产环境中，该值有可能是f同的。因为在一个事务中从日志缓冲刷新到重做日志<br>文件，并不只是在事务提交时发生，每秒都会有从日志缓冲刷新到重做日志文件的动作<br>(这部分内容我们在3.6.2小节已经讲解过了)。下面是一个生产环境下重做日志的信息：. mysql&gt; show engine innodb status\G;</p>
<p>1 row in set (0.00 sec)<br>可以看到，在生产环境下Log sequence number%        Log flushed up to%         Last checkpoint at 三个值可能是不同的。<br>7.2.2   undo<br>重做日志记录了事务的行为，可以很好地通过其进行“重做”。但是事务有时还需要<br>撤销，这时就需要undo。undo与redo正好相反，对于数据库进行修改时，数据库不但会产<br>生redo,而且还会产生一定量的undo,即使你执行的事务或语句由于某种原因失败了，或<br>者如果你用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改<br>之前的样子。与redo不同的是，redo存放在重做日志文件中，undo存放在数据库内部的一 个特殊段(segment)中，这称为undo段(undo segment), undo段位于共享表空间内。可</p>
<p>以通过pyjnnodb_pagejnfo.py工具，来査看当前共享表空间中undo的数量：<br>froot^xen-server -]# python py_innodb_page_info.py /usr/local/mysql/data/ibdatal Total number of page: 46208:<br>Insert Buffer Free List: 13093<br>Insert Buffer Bitmap: 3<br>System Page: 5<br>Transaction system Page: 1<br>Freshly Allocated Page: 4579<br>undo Log Page: 2222<br>File Segment inode: 6<br>B-tree Node: 26296</p>
<p>扩展描述页：2<br>可以看到，当前的共享表空间ibdata 1内有2222个undo页。<br>我们通常对于undo有这样的误解：undo用于将数据库物理地恢复到执行语句或事务之<br>前样子——但事实并非如此。数据库只是逻辑地恢复到原来的样子，所有修改都被逻辑地<br>取消，但是数据结构本身在回滚之后可能大不相同，因为在多用户并发系统中，可能会有<br>数十、数百甚至数千个并发事务。数据库的主要任务就是协调对于数据记录的并发访问。<br>如一个事务在修改当前一个页中某几条记录，但同时还有别的事务在对同一个页中另几条<br>记录进行修改。因此，不能将个页回滚到事务开始的样子，因为这样会影响其他事务正 在进行的工作。<br>例如：我们的事务执行了一个INSERT  10万条记录的SQL语句，这条语句可能会导致<br>分配一个新的段，即表空间会增大。如果我们执行ROLLBACK时，会将插入的事务进行<br>回滚，但是表空间的大小并不会因此而收缩。因此，当InnoDB存储引擎回滚时，它实际上<br>做的是与先前相反的工作。对于每个INSERT, InnoDB存储引擎会完成一个DELETE；对<br>于每个DELETE,  InnoDB存储引擎会执行一个INSERT；对于每个UPDATE,  InnoDB存储 引擎则会执行一个相反的UPDATE,将修改前的行放回去。<br>Oracle和Microsoft SQL Server数据库都有内部的数据字典来观察当前undo的信息*<br>InnoDB存储引擎在这方面做得还是不够的，所以DBA只能通过原理和经验来进行判断。 我写过一个补丁（patch）来扩展SHOW ENGINE INNODB STATUS命令的显示结果，可 以用来査看当前内存缓冲池中undo页的数量，如下代码所示。</p>
<p>可以看到，当前内存缓冲中有1个undo页。接着我们开启一个事务，执行插入10万条 记录的操作，需要注意的是，这并不进行提交操作：<br>mysql&gt; create table t like order_line;<br>Query OK, 0 rows affected (0.23 sec)<br>mysql&gt; insert into t select *  from order一line limit 100000;<br>Query OK, 100000 rows affected (45.01 sec)<br>Records: 100000  Duplicates:   0  Warnings:   0<br>之后在另一个会话中执行命令SHOW ENGINE INNODB STATUS,可以看到之前的会 话产生的undo量：</p>
<p>1 row in set (12.38 sec)<br>可以看到，此时undo页的数量变成了129,也就是说，刚才的一个事务大致产生了129<br>个undo页。另外，即使对INSERT的事务进行了提交，我们在一段时间内还是可以看到内<br>存中有129个undo页。这是因为，对于undo页的回收是在master thread中进行的，master<br>thread也不是每次回收所有的undo页。关于master thread的工作原理，我们在第2.3.1小节曾 介绍过。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/集合/HashMap/HashMap源码解析/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/集合/HashMap/HashMap源码解析/index.html" itemprop="url">HashMap源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T15:01:18+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合/index.html" itemprop="url" rel="index">
                    <span itemprop="name">集合</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/集合/HashMap/index.html" itemprop="url" rel="index">
                    <span itemprop="name">HashMap</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/集合/HashMap/HashMap源码解析/index.html" class="leancloud_visitors" data-flag-title="HashMap源码解析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK8的HashMap源码进行分析。</p>
<h1 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h1><p>在讨论哈希表之前，我们先大概了解下其他数据结构</p>
<p>　　<strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p>
<p>　　<strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p>
<p>　　<strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p>
<p>　　<strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/集合/HashMap/HashMap源码解析/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/consectetur/malesuada/做好面试前的准备工作/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/consectetur/malesuada/做好面试前的准备工作/index.html" itemprop="url">做好面试前的准备工作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T12:34:18+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/consectetur/index.html" itemprop="url" rel="index">
                    <span itemprop="name">consectetur</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/consectetur/malesuada/index.html" itemprop="url" rel="index">
                    <span itemprop="name">malesuada</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/consectetur/malesuada/做好面试前的准备工作/index.html" class="leancloud_visitors" data-flag-title="做好面试前的准备工作">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>做好面试前的准备工作，这个很重要！ </p>
<p>俗话说，磨刀不误砍柴工，做好面试前的准备工作可以帮助大家更好的应对面试官的问题以及面试中的突发情况。</p>
<p>那么面试前我们都有哪些要做的准备工作呢？</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/consectetur/malesuada/做好面试前的准备工作/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/shariding-jdbc/Shariding-jdbc分库分表笔记/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/shariding-jdbc/Shariding-jdbc分库分表笔记/index.html" itemprop="url">Shariding-jdbc分库分表笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T15:01:18+08:00">
                2019-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shariding-jdbc/index.html" itemprop="url" rel="index">
                    <span itemprop="name">shariding-jdbc</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/shariding-jdbc/Shariding-jdbc分库分表笔记/index.html" class="leancloud_visitors" data-flag-title="Shariding-jdbc分库分表笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前yjsj_jianyancgjg已接近1亿，yysy_jianyanbg已达到1000万，且这两张表数据增长十分快速，为了走可持续发展道路，决定对这两张表进行水平拆分。</p>
<h2 id="被淘汰的tidb"><a href="#被淘汰的tidb" class="headerlink" title="被淘汰的tidb"></a>被淘汰的tidb</h2><p>上周对tidb进行的压力测试，结果表明在持续并发下，tidb不够稳定，会莫名出现查询缓慢导致请求失败的情况，这在业务系统中是不能忍受的，所以排除将数据迁移至tidb的方法，还是使用传统的分库分表方案。</p>
<h1 id="中间件的选择"><a href="#中间件的选择" class="headerlink" title="中间件的选择"></a>中间件的选择</h1><p>实现分库分表的方式有很多种，市面上也有很多的框架或工具。从切入点来说，整体分为五种:</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/382306343-5c07cde261b29_articlex.png" alt></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/shariding-jdbc/Shariding-jdbc分库分表笔记/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/java基础/volatile/volatile关键字的作用以及原理/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java基础/volatile/volatile关键字的作用以及原理/index.html" itemprop="url">volatile关键字的作用以及原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T01:40:36+08:00">
                2019-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/index.html" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/volatile/index.html" itemprop="url" rel="index">
                    <span itemprop="name">volatile</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/java基础/volatile/volatile关键字的作用以及原理/index.html" class="leancloud_visitors" data-flag-title="volatile关键字的作用以及原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="物理计算机的并发问题"><a href="#物理计算机的并发问题" class="headerlink" title="物理计算机的并发问题"></a>物理计算机的并发问题</h1><p>CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。内存和硬盘的运算速度和CPU查了几个数量级。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I/O速度和CPU运算速度之间的不匹配问题。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/cpu_mesi.jpg" alt></p>
<p>所谓高速缓存也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p>
<p>但是高速缓存引入了一个新的问题：缓存一致性（Cache Coherence）。在多核CPU系统中，每个CPU都有自己的高速缓存，而它们又公用一块主内存（Main Memory）。当多个CPU的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存不一致。如果真发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？</p>
<h2 id="解决缓存一致性问题"><a href="#解决缓存一致性问题" class="headerlink" title="解决缓存一致性问题"></a>解决缓存一致性问题</h2><p>一般来说，有两种方式解决缓存一致性问题</p>
<ul>
<li><p>通过在总线加LOCK#锁的方式</p>
</li>
<li><p>通过缓存一致性协议</p>
</li>
</ul>
<p>这2种方式都是硬件层面上提供的方式。</p>
<p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>由于总线加Lock锁的方式效率低下，后来便出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：<strong>当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取</strong>。</p>
<h2 id="CPU乱序执行优化"><a href="#CPU乱序执行优化" class="headerlink" title="CPU乱序执行优化"></a>CPU乱序执行优化</h2><p>除了增加高速缓存外，为了使得处理器内部的运算单元能够尽量被充分利用，处理器可能会对输入代码进行乱序执行(Out-Of-Order Execution)优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行是一致的，但不保证程序中各个语句执行的先后顺序和输入的顺序一致。Java虚拟机的即时编译器也有类似的指令重排序（Instrution Reorder）优化。</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型和上面处理器、高速缓存、主内存间的交互关系有很高的可比性。Java虚拟机规范视图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽调各种硬件和操作系统的内存访问差异，以实现让Java程序在各个平台下都能达到一致的内存访问效果。</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/JMM.png" alt></p>
<p>Java内存模型规定了所有的变量(注意这里的变量包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量于方法参数，后者是线程私有的，不会被共享，自然就不会存在竞争问题。)都存储在主内存中。每条线程还有自己的工作内存(Working Memory,可与前面讲得处理器高速缓存类比)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存完成。</p>
<h1 id="并发中的原子性、可见性、有序性问题"><a href="#并发中的原子性、可见性、有序性问题" class="headerlink" title="并发中的原子性、可见性、有序性问题"></a>并发中的原子性、可见性、有序性问题</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>所谓原子性或原子操作是指不会被<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6" target="_blank" rel="noopener">线程调度</a>机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）</p>
<p>在java中，可以大致认为<strong>对基本数据类型的访问读写具备原子性</strong></p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是下面这行代码便不是原子操作了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">10</span>;</span><br><span class="line">a++;</span><br></pre></td></tr></table></figure></p>
<p>a++ 实际上包含了三个操作:</p>
<ol>
<li>读取变量a的值；</li>
<li>对a进行加一的操作；</li>
<li>将计算后的值再赋值给变量a</li>
</ol>
<p>这三个操作无法构成原子性。</p>
<h3 id="如何保证原子性"><a href="#如何保证原子性" class="headerlink" title="如何保证原子性"></a>如何保证原子性</h3><p>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write,我们大致可以认为基本数据类型的访问读写是具备原子性的（例 外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。</p>
<p>但是在某些业务场景，需要更大范围的原子性保证。Java内存模型提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更髙展次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块一ynchronized关键字，因此在synchronized块之间的操作也具备原子性。</p>
<h4 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h4><p>此处扩展下内存间交互操作，Java内存模型中定义了以下8种操作来完成。虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p>
<ul>
<li>lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；</li>
<li>unlock(解锁):作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；</li>
<li>load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本</li>
<li>use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；</li>
<li>assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；</li>
<li>write（操作）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li>
</ul>
<p>如果要把一个变量从主内存复制到工作内存。那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插人其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b, load b, load a。</p>
<h4 id="volatile不能保证原子性"><a href="#volatile不能保证原子性" class="headerlink" title="volatile不能保证原子性"></a>volatile不能保证原子性</h4><p> <a href="https://www.cnblogs.com/imfjj/p/6109876.html" target="_blank" rel="noopener">volatile不能保证原子性</a></p>
<p>由于volatile不能保证原子性，在使用volatile时要注意在<strong>不符合</strong>以下两条规则的运算场景中，我们仍然要<br>通过加锁(使用synchronized或java.util.concurrent中的原子类)来保证原子性。</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通<br>过在变景修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。</p>
<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行<br>store、write操作）”这条规则获得的。</p>
<p><a href="https://www.jianshu.com/p/d53bf830fa09" target="_blank" rel="noopener">让你彻底理解Synchronized</a></p>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>被volatile关键字修饰的变量则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。当一个变量被声明为valatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。</p>
<p>下面是一个在双检索单例中，使用volatile关键字的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双重检查加锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Singleton</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>所谓有序性是指：程序执行的顺序按照代码的先后顺序执行，禁止进行指令重排序。</p>
<p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的； 如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-ThreadAs-IfSerial Semantics）,后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p>
<h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><p>Java语言提供了 volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的。这条规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
<p>除了这两个关键字外，Java 内存模型还具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从 happens-before 原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>如下是 happens-before 的8条原则，摘自 《深入理解Java虚拟机》。</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作；</li>
<li>volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始；</li>
</ul>
<p>在上面双检索单例的代码中，<strong>instance = new Singleton();</strong> 这一行代码并不是原子性的，它的底层其实分为三个步骤:</p>
<ol>
<li>为 Singleton 对象分配内存 memory = allocate();</li>
<li>初始化对象</li>
<li>设置 instance 指向对象的内存空间</li>
</ol>
<p>因为步骤 2 和步骤 3 需要依赖步骤 1，而步骤 2 和 步骤 3 并没有依赖关系，所以这两条语句有可能会发生指令重排，也就是或有可能步骤 3 在步骤 2 的之前执行。</p>
<p>在这种情况下，步骤 3 执行了，但是步骤 2 还没有执行，也就是说 instance 实例还没有初始化完毕，正好，在此刻，线程 2 判断 instance 不为 null，所以就直接返回了 instance 实例，但是，这个时候 instance 其实是一个不完全的对象，所以，在使用的时候就会出现问题。</p>
<p>而使用 volatile 关键字，也就是使用了 “对一个 volatile修饰的变量的写，happens-before于任意后续对该变量的读” 这一原则，对应到上面的初始化过程，步骤2 和 3 都是对 instance 的写，所以一定发生于后面对 instance 的读，也就是不会出现返回不完全初始化的 instance 这种可能。</p>
<p>volatile保证有序性的原理是通过添加内存屏障实现的。</p>
<p><a href="https://www.jianshu.com/p/157279e6efdb" target="_blank" rel="noopener"># 让你彻底理解volatile</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/redis/redis zset数据结构使用案例以及原理解析/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/redis/redis zset数据结构使用案例以及原理解析/index.html" itemprop="url">redis zset数据结构使用案例以及原理解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T19:40:36+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/index.html" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/redis/redis zset数据结构使用案例以及原理解析/index.html" class="leancloud_visitors" data-flag-title="redis zset数据结构使用案例以及原理解析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于redis，我使用最多的数据结构就是简单的String。对于其他数据结构list、set、hash、zset，乃至于更高级的HyperLogLog、布隆过滤器，基本没有使用过，这次在工作中，恰好遇到需要使用zset的业务场景，特此记录。</p>
<h1 id="zset数据结构介绍"><a href="#zset数据结构介绍" class="headerlink" title="zset数据结构介绍"></a>zset数据结构介绍</h1><p>zset 可能是 Redis 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「跳跃列表」的数据结构。</p>
<p>zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。</p>
<p>zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。</p>
<p>zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/redis/redis zset数据结构使用案例以及原理解析/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/uncategorized/Java-IO模型/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/Java-IO模型/index.html" itemprop="url">Java IO模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-20T20:46:00+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/uncategorized/Java-IO模型/index.html" class="leancloud_visitors" data-flag-title="Java IO模型">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="Linux系统的五种IO模式"><a href="#Linux系统的五种IO模式" class="headerlink" title="Linux系统的五种IO模式"></a>Linux系统的五种IO模式</h1><p>Java 的 IO 模型本质上还是利用操作系统提供的接口来实现,所以最好先了解Linux底层模型。推荐阅读<a href="https://segmentfault.com/a/1190000003063859?utm_source=Weibo&amp;utm_medium=shareLink&amp;utm_campaign=socialShare&amp;from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></p>
<h1 id="Java-IO模型的演变"><a href="#Java-IO模型的演变" class="headerlink" title="Java IO模型的演变"></a>Java IO模型的演变</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>在JDK1.4之前，基于Java的所有Socket通信都采用同步阻塞模式(BIO)，这种一请求一应答的通信模型简化了上层的应用开发，但是在性能和可靠性方面却存在着巨大的瓶颈。当并发量增大，响应时间延迟增大之后，采用Java BIO开发的服务端只有通过硬件的不断扩容来满足高并发和低延迟，它极大的增加了企业的成本，随着集群规模的不断膨胀，系统的可维护性也面临巨大的挑战。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/uncategorized/Java-IO模型/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/java基础/equals/==，equals，hashCode的区别和联系/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java基础/equals/==，equals，hashCode的区别和联系/index.html" itemprop="url">==，equals，hashCode的区别和联系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T19:40:36+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/index.html" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/equals/index.html" itemprop="url" rel="index">
                    <span itemprop="name">equals</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/java基础/equals/==，equals，hashCode的区别和联系/index.html" class="leancloud_visitors" data-flag-title="==，equals，hashCode的区别和联系">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="和equals"><a href="#和equals" class="headerlink" title="== 和equals"></a>== 和equals</h2><p>== 比较的是对象在内存的地址。equals()定义在Object中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这意味着所有对象都有equals()方法,并且默认情况下equals()方法和==一样比较的是对象在内存的地址值。<br>一般引用数据类型之间的比较，需要重写equals，让其比较对象的字段值。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/java基础/equals/==，equals，hashCode的区别和联系/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/java基础/集合/ArrayList 源码解析/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java基础/集合/ArrayList 源码解析/index.html" itemprop="url">Java集合之ArrayList 源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T19:40:36+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/index.html" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/集合/index.html" itemprop="url" rel="index">
                    <span itemprop="name">集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/java基础/集合/ArrayList 源码解析/index.html" class="leancloud_visitors" data-flag-title="Java集合之ArrayList 源码解析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>ArrayList是Java最常用的几种数据结构之一， 同时也是面试热点。了解其内部实现原理是非常必要的。</p>
<h1 id="创建ArrayList"><a href="#创建ArrayList" class="headerlink" title="创建ArrayList"></a>创建ArrayList</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Object&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">ArrayList&lt;Object&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;(list2);</span><br></pre></td></tr></table></figure>
<p>ArrayList为我们提供了三个构造方法。我们创建ArrayList对象除了使用空参构造，还可以传递一个int数值，指定初始容量或者传递一个集合。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/java基础/集合/ArrayList 源码解析/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/JVM/Java 虚拟机内存模型/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/JVM/Java 虚拟机内存模型/index.html" itemprop="url">Java 虚拟机内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T19:40:36+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/index.html" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/JVM/Java 虚拟机内存模型/index.html" class="leancloud_visitors" data-flag-title="Java 虚拟机内存模型">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>根据《Java虚拟机规范(Java SE 7 版)》的规定，Java虚拟机所管理的内存包括几下几个运行时数据数据:</p>
<p><img src="https://keji-image.oss-cn-hangzhou.aliyuncs.com/super-blog/Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="在这里插入图片描述"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/JVM/Java 虚拟机内存模型/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/spring/Spring@Value注解总是null问题记录/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/spring/Spring@Value注解总是null问题记录/index.html" itemprop="url">Spring@Value注解总是null问题记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T19:40:36+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/index.html" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/spring/Spring@Value注解总是null问题记录/index.html" class="leancloud_visitors" data-flag-title="Spring@Value注解总是null问题记录">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用@value注解之后，字段总是为空。后来发现是因为字段使用了static修饰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestValue &#123;</span><br><span class="line">    @Value(&quot;$&#123;appEnv&#125;&quot;)</span><br><span class="line">    private static String appenv; //null</span><br><span class="line"></span><br><span class="line">    public String test() &#123;</span><br><span class="line">        return appenv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>spring的依赖注入不支持为static变量注入。spring 依赖注入的底层原理还是利用反射来创建对象。而static变量，在jvm加载类的时候便已经创建，存在于方法区，被所有实例共享，属于类的属性而不是对象的属性。spring是基于对象层面的依赖注入。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/spring/Spring@Value注解总是null问题记录/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/netty/netty1/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/netty/netty1/index.html" itemprop="url">netty系列之--1.netty框架基本介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T19:40:36+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/netty/index.html" itemprop="url" rel="index">
                    <span itemprop="name">netty</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/netty/netty1/index.html" class="leancloud_visitors" data-flag-title="netty系列之--1.netty框架基本介绍">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="netty是什么？"><a href="#netty是什么？" class="headerlink" title="netty是什么？"></a>netty是什么？</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/java8/optional/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java8/optional/index.html" itemprop="url">Java8新特性 使用Optional避免NPE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T12:24:01+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java8/index.html" itemprop="url" rel="index">
                    <span itemprop="name">java8</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/java8/optional/index.html" class="leancloud_visitors" data-flag-title="Java8新特性 使用Optional避免NPE">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信每一个Java程序员都碰到过NPE异常，每个避免NPE，往往会在代码中写很多if判断，形成代码污染。为了解决这个问题，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/java8/optional/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/other/hexo travis 阿里云oss持续集成个人博客/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/other/hexo travis 阿里云oss持续集成个人博客/index.html" itemprop="url">hexo+travis+阿里云oss持续集成个人博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T19:41:29+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/other/index.html" itemprop="url" rel="index">
                    <span itemprop="name">other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/other/hexo travis 阿里云oss持续集成个人博客/index.html" class="leancloud_visitors" data-flag-title="hexo+travis+阿里云oss持续集成个人博客">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>这两天抽空用hexo搭建了一个静态博客，并且使用travis+github pages做持续集成。后来对github pages的响应速度不是很满意，便将博客换成了hexo+travis+oss。</p>
<p>实现的效果是只需要提交代码，便自动将博客更新到github pages 和oss上面。</p>
<p>使用hexo+travis+github pages 完成持续部署的过程不在赘述，网上有很多教程，不过质量参差不齐，这里推荐一篇：<br><a href="https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/" target="_blank" rel="noopener">使用Travis CI自动部署Hexo博客</a><br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/other/hexo travis 阿里云oss持续集成个人博客/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/java基础/BigDecimal/BigDecimal/index.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="克己">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/keji.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克己的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java基础/BigDecimal/BigDecimal/index.html" itemprop="url">BigDecimal使用案例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T19:40:36+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/index.html" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/BigDecimal/index.html" itemprop="url" rel="index">
                    <span itemprop="name">BigDecimal</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/java基础/BigDecimal/BigDecimal/index.html" class="leancloud_visitors" data-flag-title="BigDecimal使用案例">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="创建BigDecimal对象"><a href="#创建BigDecimal对象" class="headerlink" title="创建BigDecimal对象"></a>创建BigDecimal对象</h1><p>创建BigDecimal对象常用的方式有2种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> Bigdecimal(<span class="number">1</span>);</span><br><span class="line">BigDecimal a1 = BigDecimal.valueOf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>不推荐</strong>使用new 关键字创建Bigdecimal对象。原因是当new 的值是一个小数的时候，其真实的值并不是我们想要的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="number">1.1</span>);</span><br><span class="line">BigDecimal b1 = BigDecimal.valueOf(<span class="number">1.1</span>);</span><br><span class="line">System.out.println(<span class="string">"new的值b: "</span>+b);</span><br><span class="line">System.out.println(<span class="string">"valueOf()的值b1: "</span>+b1);</span><br></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.100000000000000088817841970012523233890533447265625</span><br><span class="line">valueOf()的值b1: 1.1</span><br></pre></td></tr></table></figure></p>
<p>这在比较大小的时候，很可能出现意想不到的结果。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/java基础/BigDecimal/BigDecimal/index.html#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/keji.jpg" alt="克己">
            
              <p class="site-author-name" itemprop="name">克己</p>
              <p class="site-description motion-element" itemprop="description">有志，则不甘为下流；有识，则知学问无尽；有恒，则断无不成之事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/index.html">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">克己</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  













  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>




  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("FvalnKzIszMJbOKGGiVSI295-gzGzoHsz", "zNxPvDhWLB6hUySme9HepOIi");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
