---
layout: post
title: Java 虚拟机内存模型
categories: 
  - JVM
---

## JVM内存模型
根据《Java虚拟机规范(Java SE 7 版)》的规定，Java虚拟机所管理的内存包括几下几个运行时数据数据:

![在这里插入图片描述](https://keji-image.oss-cn-hangzhou.aliyuncs.com/super-blog/Jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)

<!-- more -->

### 程序计数器
程序计数器是一块较小的内存空间，它可以看做当前线程所执行的字节码的行号指示器,每个线程都有一个程序计数器。如果线程执行的是Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的Native方法，这个计数器的值则为空。

### Java虚拟机栈
线程私有，生命周期和线程相同。每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机中入栈到出栈的过程。

局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型(指向了一条字节码指令的地址)。

Java虚拟机规范，规定了这个区域的两种异常状况:如果线程请求的栈深度大于虚拟机锁允许的深度，将抛出StackOverflowError；如果虚拟机可以动态扩展(大部分虚拟机都支持),在扩展时无法申请到足够的内存，将抛出OutOfMemoryError异常。

### 本地方法栈
线程私有，作用和虚拟机栈非常相似，只不过虚拟机栈为Java方法服务，本地方法栈为native方法服务。

### Java堆
Java虚拟机所管理的最大的一块内存，几乎所有的对象实例都在这里分配内存。被所有线程共享。
堆内存也是java dc发生的主要区域，因此也被称为GC堆。内内存继续细分的话，可以分为Eden区、From Survivor区、To Survivor区等。
堆内存可以是不连续的内存空间，只要逻辑上是连续的即可。可以通过-Xmx和-Xms控制大小。

### 方法区
线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编辑器编译后的代码等数据。相对而言，GC很少发生在该区域。

方法区有一个运行时常量池(Runtime Constant Pool)，Class文件除了有类的版本、字段、方法接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。