---
layout: post
title: volatile关键字的作用以及原理
date: 2019-05-13 01:40:36
categories: 
  - java基础
  - volatile
---

# 原子性、可见性、有序性

了解volatile的作用前，需要先了解三个概念:原子性、可见性和有序性

## 原子性

所谓原子性

## 可见性

## 有序性







# CPU的缓存一致性(MESI)

[](http://www.cnblogs.com/dolphin0520/p/3920373.html)


![](https://keji-image.oss-cn-hangzhou.aliyuncs.com/keji-blog-hexo/cpu_mesi.jpg)

CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I/O速度和CPU运算速度之间的不匹配问题。

所谓高速缓存也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：

```java
i = i +1;
```

当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。

这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）

```java
public class Counter {
    public static int count = 0;

    public static void inc() {
        count++;
    }

    public static void main(String[] args) throws InterruptedException {
        ExecutorService es = Executors.newFixedThreadPool(1000);
        for(int i = 0; i < 10000000; i++) {
            es.submit(Counter::inc);
        }
        es.shutdown();
        es.awaitTermination(1, TimeUnit.DAYS);
        log.info("count:{}", count);
    }
}
```
执行后count值不等于10000000

这里出现了缓存一致性问题，count被称之为共享变量，当一个共享变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。

## 解决缓存一致性问题

一般来说，有两种方式解决缓存一致性问题

- 通过在总线加LOCK#锁的方式
  
- 通过缓存一致性协议

这2种方式都是硬件层面上提供的方式。

在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。

但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。

## 缓存一致性协议

由于总线加Lock锁的方式效率低下，后来便出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：**当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取**。

